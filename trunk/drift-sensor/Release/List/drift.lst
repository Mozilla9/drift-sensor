###############################################################################
#                                                                             #
#                                                       08/Oct/2012  01:42:12 #
# IAR ANSI C/C++ Compiler V6.21.2.22939/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Projects\google_host\drift-sensor\Drift\drift.c       #
#    Command line =  D:\Projects\google_host\drift-sensor\Drift\drift.c -D    #
#                    NDEBUG -lc D:\Projects\google_host\drift-sensor\Release\ #
#                    List\ --diag_suppress Pe550 -o                           #
#                    D:\Projects\google_host\drift-sensor\Release\Obj\        #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --endian=little --cpu=ARM7TDMI-S -e --fpu=None           #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    D:\Projects\google_host\drift-sensor\ -I                 #
#                    D:\Projects\google_host\drift-sensor\Config\             #
#                    --interwork --cpu_mode thumb -Om                         #
#    List file    =  D:\Projects\google_host\drift-sensor\Release\List\drift. #
#                    lst                                                      #
#    Object file  =  D:\Projects\google_host\drift-sensor\Release\Obj\drift.o #
#                                                                             #
#                                                                             #
###############################################################################

D:\Projects\google_host\drift-sensor\Drift\drift.c
      1          /******************************************************************************/
      2          /* drift.c                                                                    */
      3          /******************************************************************************/
      4          
      5          #include "data_types.h"
      6          #include "Core\core.h"
      7          #include "Uart\v_printf.h"
      8          #include "matrix\matrix.h"
      9          #include "Drift\drift.h"
     10          
     11          
     12          static drift_threshold x_acc_thr;
     13          static drift_threshold y_acc_thr;
     14          static drift_threshold z_acc_thr;
     15          static drift_threshold pit_acc_thr;
     16          static drift_threshold mod_acc_thr;
     17          
     18          static drift_stats x_acc_stats;
     19          static drift_stats y_acc_stats;
     20          static drift_stats z_acc_stats;
     21          static drift_stats pit_acc_stats;
     22          static drift_stats mod_acc_stats;
     23          
     24          static average_buff x_acc_filter;
     25          static average_buff y_acc_filter;
     26          static average_buff z_acc_filter;
     27          static average_buff pit_acc_filter;
     28          static average_buff mod_acc_filter;
     29          
     30          
     31          
     32          /*
     33          
     34          
     35              key
     36               *  ^ x
     37                  |
     38            y     |
     39            <-----. z
     40          
     41           */
     42          
     43          
     44          
     45          /*
     46           * Acc X decision
     47           *
     48           */
     49          static void acc_x_decision_reco_drift() {
     50              static uint8_t blank = 0;
     51              static sint16_t gisteresis = 0;
     52              const sint16_t average = x_acc_filter.average_type == AVERAGE_SIMPLE
     53                                          ? get_average(&x_acc_filter) : get_weighted_average(&x_acc_filter);
     54              const sint16_t last_sample = get_last_sample(&x_acc_filter);
     55          
     56              if ((blank == 0 || blank == 1) && (average > (x_acc_thr.med + x_acc_thr.up_front - gisteresis))) {
     57                  if (blank != 1) {
     58                      DEBUG_PRINTF("x_start_acclr: %d\n\r", average);
     59                      blank = 1;
     60          
     61                      x_acc_stats.average = last_sample;
     62                      x_acc_stats.max = last_sample;
     63                      x_acc_stats.min = last_sample;
     64                      x_acc_stats.count = 1;
     65                      gisteresis = x_acc_thr.gist;
     66                  } else {
     67                      x_acc_stats.average += last_sample;
     68                      x_acc_stats.max = x_acc_stats.max > last_sample ? x_acc_stats.max : last_sample;
     69                      x_acc_stats.min = x_acc_stats.min < last_sample ? x_acc_stats.min : last_sample;
     70                      x_acc_stats.count++;
     71                  }
     72              }
     73              else if ((blank == 0 || blank == 2) && (average < (x_acc_thr.med - x_acc_thr.down_front + gisteresis))) {
     74                  if (blank != 2) {
     75                      DEBUG_PRINTF("x_start_brake: %d\n\r", average);
     76                      blank = 2;
     77          
     78                      x_acc_stats.average = last_sample;
     79                      x_acc_stats.max = last_sample;
     80                      x_acc_stats.min = last_sample;
     81                      x_acc_stats.count = 1;
     82                      gisteresis = x_acc_thr.gist;
     83                  } else {
     84                      x_acc_stats.average += last_sample;
     85                      x_acc_stats.max = x_acc_stats.max > last_sample ? x_acc_stats.max : last_sample;
     86                      x_acc_stats.min = x_acc_stats.min < last_sample ? x_acc_stats.min : last_sample;
     87                      x_acc_stats.count++;
     88                  }
     89              }
     90              else {
     91                  switch (blank) {
     92                      case 1:
     93                          serprintf("$DRIFT,XA,%x,%x,%x,%u\r\n",
     94                              (x_acc_stats.average / x_acc_stats.count), x_acc_stats.max, x_acc_stats.min, x_acc_stats.count);
     95                          
     96                          DEBUG_PRINTF("x_end_acclr");
     97                          break;
     98          
     99                      case 2:
    100                          serprintf("$DRIFT,XB,%x,%x,%x,%u\r\n",
    101                              (x_acc_stats.average / x_acc_stats.count), x_acc_stats.max, x_acc_stats.min, x_acc_stats.count);
    102                          
    103                          DEBUG_PRINTF("x_end_brake");
    104                          break;
    105          
    106                      default:
    107                          blank = 0;
    108                          gisteresis = 0;
    109                          return;
    110                  }
    111                  blank = 0;
    112                  gisteresis = 0;
    113          
    114                  DEBUG_PRINTF(": %d, %d, %d, %u\n\r",
    115                      (x_acc_stats.average / x_acc_stats.count), x_acc_stats.max, x_acc_stats.min, x_acc_stats.count);
    116              }
    117          }
    118          
    119          
    120          /*
    121           * Acc Y decision
    122           *
    123           */
    124          static void acc_y_decision_reco_drift() {
    125              static uint8_t blank = 0;
    126              static sint16_t gisteresis = 0;
    127              const sint16_t average = y_acc_filter.average_type == AVERAGE_SIMPLE
    128                                          ? get_average(&y_acc_filter) : get_weighted_average(&y_acc_filter);
    129              const sint16_t last_sample = get_last_sample(&y_acc_filter);
    130          
    131              if ((blank == 0 || blank == 1) && (average > (y_acc_thr.med + y_acc_thr.up_front - gisteresis))) {
    132                  if (blank != 1) {
    133                      DEBUG_PRINTF("y_start_left_rot: %d\n\r", average);
    134                      blank = 1;
    135          
    136                      y_acc_stats.average = last_sample;
    137                      y_acc_stats.max = last_sample;
    138                      y_acc_stats.min = last_sample;
    139                      y_acc_stats.count = 1;
    140                      gisteresis = y_acc_thr.gist;
    141                  } else {
    142                      y_acc_stats.average += last_sample;
    143                      y_acc_stats.max = y_acc_stats.max > last_sample ? y_acc_stats.max : last_sample;
    144                      y_acc_stats.min = y_acc_stats.min < last_sample ? y_acc_stats.min : last_sample;
    145                      y_acc_stats.count++;
    146                  }
    147              }
    148              else if ((blank == 0 || blank == 2) && (average < (y_acc_thr.med - y_acc_thr.down_front + gisteresis))) {
    149                  if (blank != 2) {
    150                      DEBUG_PRINTF("y_start_right_rot: %d\n\r", average);
    151                      blank = 2;
    152          
    153                      y_acc_stats.average = last_sample;
    154                      y_acc_stats.max = last_sample;
    155                      y_acc_stats.min = last_sample;
    156                      y_acc_stats.count = 1;
    157                      gisteresis = y_acc_thr.gist;
    158                  } else {
    159                      y_acc_stats.average += last_sample;
    160                      y_acc_stats.max = y_acc_stats.max > last_sample ? y_acc_stats.max : last_sample;
    161                      y_acc_stats.min = y_acc_stats.min < last_sample ? y_acc_stats.min : last_sample;
    162                      y_acc_stats.count++;
    163                  }
    164              }
    165              else {
    166                  switch (blank) {
    167                      case 1:
    168                          serprintf("$DRIFT,YL,%x,%x,%x,%u\r\n",
    169                              (y_acc_stats.average / y_acc_stats.count), y_acc_stats.max, y_acc_stats.min, y_acc_stats.count);
    170                          
    171                          DEBUG_PRINTF("y_end_left");
    172                          break;
    173          
    174                      case 2:
    175                          serprintf("$DRIFT,YR,%x,%x,%x,%u\r\n",
    176                              (y_acc_stats.average / y_acc_stats.count), y_acc_stats.max, y_acc_stats.min, y_acc_stats.count);
    177                          
    178                          DEBUG_PRINTF("y_end_right");
    179                          break;
    180          
    181                      default:
    182                          blank = 0;
    183                          gisteresis = 0;
    184                          return;
    185                  }
    186                  blank = 0;
    187                  gisteresis = 0;
    188          
    189                  DEBUG_PRINTF("_rot: %d, %d, %d, %u\n\r",
    190                      (y_acc_stats.average / y_acc_stats.count), y_acc_stats.max, y_acc_stats.min, y_acc_stats.count);
    191              }
    192          }
    193          
    194          
    195          /*
    196           * Acc Z decision
    197           *
    198           */
    199          static void acc_z_decision_reco_drift() {
                             ^
Warning[Pe177]: function "acc_z_decision_reco_drift" was declared but never
          referenced
    200              static uint8_t blank = 0;
    201              static sint16_t gisteresis = 0;
    202              const sint16_t average = z_acc_filter.average_type == AVERAGE_SIMPLE
    203                                          ? get_average(&z_acc_filter) : get_weighted_average(&z_acc_filter);
    204              const sint16_t last_sample = get_last_sample(&z_acc_filter);
    205          
    206              if ((blank == 0 || blank == 1) && (average > (z_acc_thr.med + z_acc_thr.up_front - gisteresis))) {
    207                  if (blank != 1) {
    208                      DEBUG_PRINTF("z_start_up: %d\n\r", average);
    209                      blank = 1;
    210          
    211                      z_acc_stats.average = last_sample;
    212                      z_acc_stats.max = last_sample;
    213                      z_acc_stats.min = last_sample;
    214                      z_acc_stats.count = 1;
    215                      gisteresis = z_acc_thr.gist;
    216                  } else {
    217                      z_acc_stats.average += last_sample;
    218                      z_acc_stats.max = z_acc_stats.max > last_sample ? z_acc_stats.max : last_sample;
    219                      z_acc_stats.min = z_acc_stats.min < last_sample ? z_acc_stats.min : last_sample;
    220                      z_acc_stats.count++;
    221                  }
    222              }
    223              else if ((blank == 0 || blank == 2) && (average < (z_acc_thr.med - z_acc_thr.down_front + gisteresis))) {
    224                  if (blank != 2) {
    225                      DEBUG_PRINTF("z_start_down: %d\n\r", average);
    226                      blank = 2;
    227          
    228                      z_acc_stats.average = last_sample;
    229                      z_acc_stats.max = last_sample;
    230                      z_acc_stats.min = last_sample;
    231                      z_acc_stats.count = 1;
    232                      gisteresis = z_acc_thr.gist;
    233                  } else {
    234                      z_acc_stats.average += last_sample;
    235                      z_acc_stats.max = z_acc_stats.max > last_sample ? z_acc_stats.max : last_sample;
    236                      z_acc_stats.min = z_acc_stats.min < last_sample ? z_acc_stats.min : last_sample;
    237                      z_acc_stats.count++;
    238                  }
    239              }
    240              else {
    241                  switch (blank) {
    242                      case 1:
    243                          DEBUG_PRINTF("z_end_up");
    244                          break;
    245          
    246                      case 2:
    247                          DEBUG_PRINTF("z_end_down");
    248                          break;
    249          
    250                      default:
    251                          blank = 0;
    252                          gisteresis = 0;
    253                          return;
    254                  }
    255                  blank = 0;
    256                  gisteresis = 0;
    257          
    258                  DEBUG_PRINTF(": %d, %d, %d, %u\n\r",
    259                      (z_acc_stats.average / z_acc_stats.count), z_acc_stats.max, z_acc_stats.min, z_acc_stats.count);
    260              }
    261          }
    262          
    263          
    264          /*
    265           * Acc Z_PIT decision
    266           *
    267           */
    268          static void acc_pit_decision_reco_drift() {
                             ^
Warning[Pe177]: function "acc_pit_decision_reco_drift" was declared but never
          referenced
    269              static uint16_t pit_count = 0;
    270              static uint8_t blank = 0;
    271              static sint16_t gisteresis = 0;
    272              const sint16_t average = pit_acc_filter.average_type == AVERAGE_SIMPLE
    273                                          ? get_average(&pit_acc_filter) : get_weighted_average(&pit_acc_filter);
    274              const sint16_t last_sample = get_last_sample(&pit_acc_filter);
    275          
    276              if (pit_count)
    277                  pit_count--;
    278          
    279              if (average > (pit_acc_thr.med + pit_acc_thr.up_front - gisteresis)) {
    280                  if (blank != 1) {
    281                      blank = 1;
    282          
    283                      if (pit_count) {
    284                          serprintf("$DRIFT,ZP1,%x,%x,%x,%u\r\n",
    285                              (pit_acc_stats.average / pit_acc_stats.count), pit_acc_stats.max, pit_acc_stats.min, pit_acc_stats.count);
    286                          
    287                          DEBUG_PRINTF("Z_PIT_1: %d, %d, %d, %u\n\r",
    288                              (pit_acc_stats.average / pit_acc_stats.count), pit_acc_stats.max, pit_acc_stats.min, pit_acc_stats.count);
    289                      }
    290                      pit_count = 13;
    291          
    292                      pit_acc_stats.average = last_sample;
    293                      pit_acc_stats.max = last_sample;
    294                      pit_acc_stats.min = last_sample;
    295                      pit_acc_stats.count = 1;
    296                      gisteresis = pit_acc_thr.gist;
    297                  } else {
    298                      pit_acc_stats.average += last_sample;
    299                      pit_acc_stats.max = pit_acc_stats.max > last_sample ? pit_acc_stats.max : last_sample;
    300                      pit_acc_stats.min = pit_acc_stats.min < last_sample ? pit_acc_stats.min : last_sample;
    301                      pit_acc_stats.count++;
    302                  }
    303              }
    304              else if (average < (pit_acc_thr.med - pit_acc_thr.down_front + gisteresis)) {
    305                  if (blank != 2) {
    306                      blank = 2;
    307          
    308                      if (pit_count) {
    309                          serprintf("$DRIFT,ZP2,%x,%x,%x,%u\r\n",
    310                              (pit_acc_stats.average / pit_acc_stats.count), pit_acc_stats.max, pit_acc_stats.min, pit_acc_stats.count);
    311                          
    312                          DEBUG_PRINTF("Z_PIT_2: %d, %d, %d, %u\n\r",
    313                              (pit_acc_stats.average / pit_acc_stats.count), pit_acc_stats.max, pit_acc_stats.min, pit_acc_stats.count);
    314                      }
    315                      pit_count = 13;
    316          
    317                      pit_acc_stats.average = last_sample;
    318                      pit_acc_stats.max = last_sample;
    319                      pit_acc_stats.min = last_sample;
    320                      pit_acc_stats.count = 1;
    321                      gisteresis = pit_acc_thr.gist;
    322                  } else {
    323                      pit_acc_stats.average += last_sample;
    324                      pit_acc_stats.max = pit_acc_stats.max > last_sample ? pit_acc_stats.max : last_sample;
    325                      pit_acc_stats.min = pit_acc_stats.min < last_sample ? pit_acc_stats.min : last_sample;
    326                      pit_acc_stats.count++;
    327                  }
    328              }
    329              else {
    330                  blank = 0;
    331                  gisteresis = 0;
    332              }
    333          }
    334          
    335          
    336          /*
    337           * Acc PIT_MOD decision
    338           *
    339           */
    340          static void acc_pit_mod_decision_reco_drift() {
    341              static sint32_t av_up = 0;
    342              static sint32_t av_down = 0;
    343              static uint16_t count_up = 0;
    344          
    345              static uint8_t blank = 0;
    346              static sint16_t gisteresis = 0;
    347              const sint16_t average = get_pit_average(&mod_acc_filter, mod_acc_thr.med);
    348              const sint16_t last_sample = get_last_sample(&mod_acc_filter);
    349          
    350              if (average > (mod_acc_thr.up_front - gisteresis)) {
    351                  sint16_t lls = 0;
    352                  uint32_t ccc = 0;
    353          
    354                  if (last_sample < 0) {
    355                       lls = (last_sample * -1);
    356                       ccc = 0;
    357                  } else {
    358                       lls = last_sample;
    359                       ccc = 1;
    360                  }
    361          
    362                  if (lls > mod_acc_thr.med) {
    363                      lls -= mod_acc_thr.med;
    364                  } else {
    365                      lls = mod_acc_thr.med - lls;
    366                  }
    367          
    368                  if (blank != 1) {
    369                      DEBUG_PRINTF("PIT_MOD_START: %d\n\r", average);
    370                      blank = 1;
    371          
    372                      if (ccc) {
    373                          av_up = lls;
    374                          count_up = 1;
    375                      } else {
    376                          av_down = lls;
    377                      }
    378          
    379                      count_up = ccc;
    380          
    381                      mod_acc_stats.average = last_sample;
    382                      mod_acc_stats.max = last_sample;
    383                      mod_acc_stats.min = last_sample;
    384                      mod_acc_stats.count = 1;
    385                      gisteresis = mod_acc_thr.gist;
    386                  } else {
    387                      mod_acc_stats.average += last_sample;
    388                      mod_acc_stats.max = mod_acc_stats.max > last_sample ? mod_acc_stats.max : last_sample;
    389                      mod_acc_stats.min = mod_acc_stats.min < last_sample ? mod_acc_stats.min : last_sample;
    390                      mod_acc_stats.count++;
    391          
    392                      if (ccc) {
    393                          av_up += lls;
    394                          count_up = 1;
    395                      } else {
    396                          av_down += lls;
    397                      }
    398          
    399                      count_up += ccc;
    400                  }
    401              }
    402              else {
    403                  if (blank == 1) {
    404                      serprintf("$DRIFT,ZM,%x,%x,%x,%u\r\n",
    405                          (mod_acc_stats.average / mod_acc_stats.count), mod_acc_stats.max, mod_acc_stats.min, mod_acc_stats.count);
    406                      
    407                      DEBUG_PRINTF("PIT_MOD_END: %d, %d, %d, %u, av_up=%d, av_dw=%d\n\r",
    408                          (mod_acc_stats.average / mod_acc_stats.count), mod_acc_stats.max, mod_acc_stats.min, mod_acc_stats.count,
    409                          (av_up / count_up), (av_down / (mod_acc_stats.count - count_up)));
    410                  }
    411          
    412                  blank = 0;
    413                  gisteresis = 0;
    414              }
    415          }
    416          
    417          
    418          /*
    419           * Init drift recognition
    420           *
    421           */
    422          void init_reco_drift() {
    423              // Init acc filters
    424              init_average_filter(&x_acc_filter);
    425              init_average_filter(&y_acc_filter);
    426              init_average_filter(&z_acc_filter);
    427          
    428              init_average_filter(&pit_acc_filter);
    429              set_wind_size_average_filter(&pit_acc_filter, 6);
    430              set_average_type_filter(&pit_acc_filter, AVERAGE_SIMPLE);
    431          
    432              init_average_filter(&mod_acc_filter);
    433              set_wind_size_average_filter(&mod_acc_filter, 13);
    434              set_average_type_filter(&mod_acc_filter, AVERAGE_MOD_PIT);
    435          
    436              x_acc_thr.med = 0;
    437              x_acc_thr.up_front = 2500;
    438              x_acc_thr.down_front = 2500;
    439              x_acc_thr.gist = 350;
    440          
    441              y_acc_thr.med = 0;
    442              y_acc_thr.up_front = 2500;
    443              y_acc_thr.down_front = 2500;
    444              y_acc_thr.gist = 350;
    445          
    446              z_acc_thr.med = 8000;
    447              z_acc_thr.up_front = 2500;
    448              z_acc_thr.down_front = 2500;
    449              z_acc_thr.gist = 350;
    450          
    451              pit_acc_thr.med = 8000;
    452              pit_acc_thr.up_front = 1800;
    453              pit_acc_thr.down_front = 1800;
    454              pit_acc_thr.gist = 150;
    455          
    456              mod_acc_thr.med = 8000;
    457              mod_acc_thr.up_front = 2000;
    458              mod_acc_thr.down_front = 2000;
    459              mod_acc_thr.gist = 150;
    460          }
    461          
    462          
    463          /*
    464           * Add acc samples
    465           *
    466           */
    467          void add_acc_samples_in_reco_drift(const uint16_t x_acc, const uint16_t y_acc, const uint16_t z_acc) {
    468              add_sample_in_filter(&x_acc_filter, x_acc);
    469              add_sample_in_filter(&y_acc_filter, y_acc);
    470              //add_sample_in_filter(&z_acc_filter, z_acc);
    471              //add_sample_in_filter(&pit_acc_filter, z_acc);
    472              add_sample_in_filter(&mod_acc_filter, z_acc);
    473          
    474              acc_x_decision_reco_drift();
    475              acc_y_decision_reco_drift();
    476              //acc_z_decision_reco_drift();
    477              //acc_pit_decision_reco_drift();
    478              acc_pit_mod_decision_reco_drift();
    479          }
    480          
    481          
    482          /*
    483           * Add acc matrix samples
    484           *
    485           */
    486          void add_acc_matrix_samples_in_reco_drift(const uint16_t x_acc, const uint16_t y_acc, const uint16_t z_acc) {
    487              // rotate
    488              float32_t output_vector[3];
    489              const sint16_t input_vector[3] = {x_acc, y_acc, z_acc};
    490              
    491              multiply(input_vector, get_rotation_matrix(), output_vector);
    492          
    493              add_sample_in_filter(&x_acc_filter, (sint16_t)output_vector[0]);
    494              add_sample_in_filter(&y_acc_filter, (sint16_t)output_vector[1]);
    495              //add_sample_in_filter(&z_acc_filter, (sint16_t)output_vector[2]);
    496              //add_sample_in_filter(&pit_acc_filter, (sint16_t)output_vector[2]);
    497              add_sample_in_filter(&mod_acc_filter, (sint16_t)output_vector[2]);
    498          
    499              acc_x_decision_reco_drift();
    500              acc_y_decision_reco_drift();
    501              //acc_z_decision_reco_drift();
    502              //acc_pit_decision_reco_drift();
    503              acc_pit_mod_decision_reco_drift();
    504          }
    505          
    506          
    507          /*
    508           * Set x threshold
    509           *
    510           */
    511          void set_x_acc_threshold(const sint16_t _med, const sint16_t _up, const sint16_t _down, const sint16_t _gist) {
    512              x_acc_thr.med = _med;
    513              x_acc_thr.up_front = (_up < 0) ? (-1 * _up) : _up;
    514              x_acc_thr.down_front = (_down < 0) ? (-1 * _down) : _down;
    515              x_acc_thr.gist= (_gist < 0) ? (-1 * _gist) : _gist;
    516          }
    517          
    518          
    519          /*
    520           * Get x_acc_thr
    521           *
    522           */
    523          drift_threshold * get_x_acc_threshold() {
    524              return &x_acc_thr;
    525          }
    526          
    527          
    528          /*
    529           * Set y threshold
    530           *
    531           */
    532          void set_y_acc_threshold(const sint16_t _med, const sint16_t _up, const sint16_t _down, const sint16_t _gist) {
    533              y_acc_thr.med = _med;
    534              y_acc_thr.up_front = (_up < 0) ? (-1 * _up) : _up;
    535              y_acc_thr.down_front = (_down < 0) ? (-1 * _down) : _down;
    536              y_acc_thr.gist= (_gist < 0) ? (-1 * _gist) : _gist;
    537          }
    538          
    539          
    540          /*
    541           * Get y_acc_thr
    542           *
    543           */
    544          drift_threshold * get_y_acc_threshold() {
    545              return &y_acc_thr;
    546          }
    547          
    548          
    549          /*
    550           * Set z threshold
    551           *
    552           */
    553          void set_z_acc_threshold(const sint16_t _med, const sint16_t _up, const sint16_t _down, const sint16_t _gist) {
    554              z_acc_thr.med = _med;
    555              z_acc_thr.up_front = (_up < 0) ? (-1 * _up) : _up;
    556              z_acc_thr.down_front = (_down < 0) ? (-1 * _down) : _down;
    557              z_acc_thr.gist= (_gist < 0) ? (-1 * _gist) : _gist;
    558          }
    559          
    560          
    561          /*
    562           * Get z_acc_thr
    563           *
    564           */
    565          drift_threshold * get_z_acc_threshold() {
    566              return &z_acc_thr;
    567          }
    568          
    569          
    570          /*
    571           * Set pit threshold
    572           *
    573           */
    574          void set_pit_acc_threshold(const sint16_t _med, const sint16_t _up, const sint16_t _down, const sint16_t _gist) {
    575              pit_acc_thr.med = _med;
    576              pit_acc_thr.up_front = (_up < 0) ? (-1 * _up) : _up;
    577              pit_acc_thr.down_front = (_down < 0) ? (-1 * _down) : _down;
    578              pit_acc_thr.gist= (_gist < 0) ? (-1 * _gist) : _gist;
    579          }
    580          
    581          
    582          /*
    583           * Get pit_acc_thr
    584           *
    585           */
    586          drift_threshold * get_pit_acc_threshold() {
    587              return &pit_acc_thr;
    588          }
    589          
    590          
    591          /*
    592           * Set mod threshold
    593           *
    594           */
    595          void set_mod_acc_threshold(const sint16_t _med, const sint16_t _up, const sint16_t _down, const sint16_t _gist) {
    596              mod_acc_thr.med = _med;
    597              mod_acc_thr.up_front = (_up < 0) ? (-1 * _up) : _up;
    598              mod_acc_thr.down_front = (_down < 0) ? (-1 * _down) : _down;
    599              mod_acc_thr.gist= (_gist < 0) ? (-1 * _gist) : _gist;
    600          }
    601          
    602          
    603          /*
    604           * Get pit_acc_thr
    605           *
    606           */
    607          drift_threshold * get_mod_acc_threshold() {
    608              return &mod_acc_thr;
    609          }
    610          
    611          
    612          /*
    613           * Get x filter
    614           *
    615           */
    616          average_buff * get_x_drift_filter() {
    617              return &x_acc_filter;
    618          }
    619          
    620          
    621          /*
    622           * Get y filter
    623           *
    624           */
    625          average_buff * get_y_drift_filter() {
    626              return &y_acc_filter;
    627          }
    628          
    629          
    630          /*
    631           * Get z filter
    632           *
    633           */
    634          average_buff * get_z_drift_filter() {
    635              return &z_acc_filter;
    636          }
    637          
    638          
    639          /*
    640           * Get pit filter
    641           *
    642           */
    643          average_buff * get_pit_drift_filter() {
    644              return &pit_acc_filter;
    645          }
    646          
    647          
    648          /*
    649           * Get mod filter
    650           *
    651           */
    652          average_buff * get_mod_drift_filter() {
    653              return &mod_acc_filter;
    654          }
    655          

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     acc_pit_mod_decision_reco_drift
                                        40
     acc_x_decision_reco_drift          24
     acc_y_decision_reco_drift          24
     add_acc_matrix_samples_in_reco_drift
                                        32
     add_acc_samples_in_reco_drift      16
     get_mod_acc_threshold               0
     get_mod_drift_filter                0
     get_pit_acc_threshold               0
     get_pit_drift_filter                0
     get_x_acc_threshold                 0
     get_x_drift_filter                  0
     get_y_acc_threshold                 0
     get_y_drift_filter                  0
     get_z_acc_threshold                 0
     get_z_drift_filter                  0
     init_reco_drift                    16
     set_mod_acc_threshold               4
     set_pit_acc_threshold               4
     set_x_acc_threshold                 4
     set_y_acc_threshold                 4
     set_z_acc_threshold                 4


   Section sizes:

     Function/Label                          Bytes
     --------------                          -----
     acc_x_decision_reco_drift                458
     acc_y_decision_reco_drift                466
     acc_pit_mod_decision_reco_drift
                                              356
     blank                                     76
     blank
     x_acc_thr
     z_acc_thr
     pit_acc_thr
     mod_acc_thr
     x_acc_stats
     mod_acc_stats
     gisteresis
     count_up
     gisteresis
     av_up
     av_down
     blank                                     26
     y_acc_thr
     y_acc_stats
     gisteresis
     x_acc_filter                            1040
     y_acc_filter
     z_acc_filter
     pit_acc_filter
     mod_acc_filter
     init_reco_drift                          154
     add_acc_samples_in_reco_drift             68
     add_acc_matrix_samples_in_reco_drift
                                              108
     set_x_acc_threshold                       34
     get_x_acc_threshold                        6
     set_y_acc_threshold                       34
     get_y_acc_threshold                        6
     set_z_acc_threshold                       34
     get_z_acc_threshold                        6
     set_pit_acc_threshold                     34
     get_pit_acc_threshold                      6
     set_mod_acc_threshold                     34
     get_mod_acc_threshold                      6
     get_x_drift_filter                         4
     get_y_drift_filter                         6
     get_z_drift_filter                         4
     get_pit_drift_filter                       4
     get_mod_drift_filter                       4
     ??DataTable17                              4
     ??DataTable17_1                            4
     ?<Constant "x_start_acclr: %d\n\r">       20
     ?<Constant "x_start_brake: %d\n\r">       20
     ?<Constant "$DRIFT,XA,%x,%x,%x,%u\r\n">   24
     ?<Constant "x_end_acclr">                 12
     ?<Constant ": %d, %d, %d, %u\n\r">        20
     ?<Constant "$DRIFT,XB,%x,%x,%x,%u\r\n">   24
     ?<Constant "x_end_brake">                 12
     ??DataTable18                              4
     ??DataTable18_1                            4
     ?<Constant "y_start_left_rot: %d\n\r">    24
     ?<Constant "y_start_right_rot: %d\n\r">   24
     ?<Constant "$DRIFT,YL,%x,%x,%x,%u\r\n">   24
     ?<Constant "y_end_left">                  12
     ?<Constant "_rot: %d, %d, %d, %u\n\r">    24
     ?<Constant "$DRIFT,YR,%x,%x,%x,%u\r\n">   24
     ?<Constant "y_end_right">                 12
     ?<Constant "PIT_MOD_START: %d\n\r">       20
     ??DataTable26                              4
     ??DataTable28                              4
     ??DataTable37                              4
     ??DataTable37_1                            4
     ??DataTable37_2                            4
     ??DataTable37_3                            4
     ??DataTable37_4                            4
     ??DataTable37_5                            4
     ??DataTable37_6                            4
     ?<Constant "$DRIFT,ZM,%x,%x,%x,%u\r\n">   24
     ?<Constant "PIT_MOD_END: %d, %d, ...">    52
      Others                                    6

 
 1 142 bytes in section .bss
 2 262 bytes in section .text
 
 2 256 bytes of CODE memory (+ 6 bytes shared)
 1 142 bytes of DATA memory

Errors: none
Warnings: 2
