###############################################################################
#                                                                             #
#                                                       08/Oct/2012  01:42:21 #
# IAR ANSI C/C++ Compiler V6.21.2.22939/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Projects\google_host\drift-sensor\Uart\uart2.c        #
#    Command line =  D:\Projects\google_host\drift-sensor\Uart\uart2.c -D     #
#                    NDEBUG -lc D:\Projects\google_host\drift-sensor\Release\ #
#                    List\ --diag_suppress Pe550 -o                           #
#                    D:\Projects\google_host\drift-sensor\Release\Obj\        #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --endian=little --cpu=ARM7TDMI-S -e --fpu=None           #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    D:\Projects\google_host\drift-sensor\ -I                 #
#                    D:\Projects\google_host\drift-sensor\Config\             #
#                    --interwork --cpu_mode thumb -Om                         #
#    List file    =  D:\Projects\google_host\drift-sensor\Release\List\uart2. #
#                    lst                                                      #
#    Object file  =  D:\Projects\google_host\drift-sensor\Release\Obj\uart2.o #
#                                                                             #
#                                                                             #
###############################################################################

D:\Projects\google_host\drift-sensor\Uart\uart2.c
      1          /******************************************************************************/
      2          /* uart2.c                                                                    */
      3          /******************************************************************************/
      4          
      5          
      6          #include "data_types.h"
      7          #include "Core\core.h"
      8          #include "Uart\uart2.h"
      9          
     10          
     11          
     12          /*
     13           * Init uart2
     14           *
     15           */
     16          void init_uart2(const uint32_t _baudrate, const uint8_t _key) {
     17              U2IER = 0UL;                  // int dis
     18          
     19              PCONP_bit.PCUART2 = 1;
     20          
     21              PINSEL4_bit.P2_8 = 2;         // TXD
     22              PINSEL4_bit.P2_9 = 2;         // RXD
     23          
     24              FIO2DIR_bit.P2_8 = 1;         // TXD
     25              FIO2DIR_bit.P2_9 = 0;         // RXD
     26          
     27              PINMODE4_bit.P2_8 = 2;        // TXD PULL_RES - dis
     28              PINMODE4_bit.P2_9 = 2;        // RXD
     29          
     30              U2LCR = 0x80 | _key;          // 8 bits, no Parity, 1 Stop bit
     31              U2FDR_bit.DIVADDVAL = 0;
     32              U2FDR_bit.MULVAL = 0;
     33          
     34              uint32_t Br;
     35          
     36              if(_baudrate == 115200) {
     37                  // ! for FPCLK=28800000
     38                  U2DLM = 0;
     39                  U2DLL = 13;
     40                  U2FDR_bit.DIVADDVAL = 1;
     41                  U2FDR_bit.MULVAL = 5;
     42              }
     43              else {
     44                  Br = (FPCLK / 16) / _baudrate;
     45                  U2DLM = Br / 256;
     46                  U2DLL = Br % 256;
     47              }
     48          
     49              U2LCR = _key;                  // DLAB = 0
     50              U2FCR = 0x41;                  // Enable and reset TX and RX FIFO, size 4 bytes
     51          }
     52          
     53          
     54          
     55          /*
     56           * Uart2 interrupt handler
     57           *
     58           */
     59          __irq __arm void __interrupt_handler_uart2() {
     60              uint8_t IIR_VALUE = U2IIR;
     61              const uint8_t LSR_VALUE = U2LSR;
     62          
     63              IIR_VALUE >>= 1;
     64              IIR_VALUE &= 0x07;
     65          
     66              switch(IIR_VALUE)
     67              {
     68                  //----------------------------------------------------------------------
     69                  case IIR_RLS:
     70                    if (LSR_VALUE & LSR_RXFE) {
     71                        U2SCR = U2RBR;            // bad data flush
     72                    }
     73                    break;
     74          
     75                  //----------------------------------------------------------------------
     76                  case IIR_RDA:
     77                    for (uint32_t i = 0; i < UART2_FIFO_TRLEVEL; i++) {
     78                        //add_byte(U2RBR);
     79                    }
     80                    break;
     81          
     82                  //----------------------------------------------------------------------
     83                  case IIR_CTI:
     84                    do {
     85                        //add_byte(U2RBR);
     86                    } while (U2LSR & LSR_RDR);
     87                    break;
     88          
     89                  //----------------------------------------------------------------------
     90                  case IIR_THRE:
     91                    break;
     92          
     93                  //----------------------------------------------------------------------
     94                  default:
     95                    break;
     96              }
     97              
     98              VICADDRESS = 0;
     99          }

   Maximum stack usage in bytes:

     Function                  .cstack
     --------                  -------
     __interrupt_handler_uart2     16
     init_uart2                    28


   Section sizes:

     Function/Label            Bytes
     --------------            -----
     _A_PCONP                     4
     VICADDRESS                   4
     _A_PINSEL4                   4
     _A_PINMODE4                  4
     _A_FIO2DIR                   4
     U2RBRTHR                     1
     _A_U2IER                     4
     _A_U2FCR                     4
     _A_U2LCR                     4
     _A_U2LSR                     4
     U2SCR                        1
     _A_U2FDR                     4
     init_uart2                 188
     __interrupt_handler_uart2  132
     ??DataTable0                 4
     ??DataTable0_1               4
     ??DataTable0_2               4
     ??DataTable0_3               4
     ??DataTable0_4               4
     ??DataTable0_5               4
     ??DataTable0_6               4
     ??DataTable0_7               4

 
  42 bytes in section .data
 352 bytes in section .text
 
 352 bytes of CODE memory
   0 bytes of DATA memory (+ 42 bytes shared)

Errors: none
Warnings: none
