###############################################################################
#                                                                             #
#                                                       08/Oct/2012  01:42:15 #
# IAR ANSI C/C++ Compiler V6.21.2.22939/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Projects\google_host\drift-sensor\I2C\i2c2.c          #
#    Command line =  D:\Projects\google_host\drift-sensor\I2C\i2c2.c -D       #
#                    NDEBUG -lc D:\Projects\google_host\drift-sensor\Release\ #
#                    List\ --diag_suppress Pe550 -o                           #
#                    D:\Projects\google_host\drift-sensor\Release\Obj\        #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --endian=little --cpu=ARM7TDMI-S -e --fpu=None           #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    D:\Projects\google_host\drift-sensor\ -I                 #
#                    D:\Projects\google_host\drift-sensor\Config\             #
#                    --interwork --cpu_mode thumb -Om                         #
#    List file    =  D:\Projects\google_host\drift-sensor\Release\List\i2c2.l #
#                    st                                                       #
#    Object file  =  D:\Projects\google_host\drift-sensor\Release\Obj\i2c2.o  #
#                                                                             #
#                                                                             #
###############################################################################

D:\Projects\google_host\drift-sensor\I2C\i2c2.c
      1          /******************************************************************************/
      2          /* i2c2.c                                                                     */
      3          /******************************************************************************/
      4          
      5          
      6          #include "data_types.h"
      7          #include "Core\core.h"
      8          #include "Uart\v_printf.h"
      9          #include "I2c\i2c2.h"
     10          #include "Protothread\pt.h"
     11          
     12          static i2c_data * pData;
     13          
     14          
     15          /*
     16           * Init i2c2
     17           *
     18           */
     19          void init_i2c2() {
     20              PCONP_bit.PCI2C2 = 1;
     21          
     22              I2C2CONCLR = I2C_EN;       // dis module
     23          
     24              // Init pins
     25              PINSEL0_bit.P0_10 = 2;     // SDA0
     26              PINSEL0_bit.P0_11 = 2;     // SCL0
     27          
     28              PINMODE0_bit.P0_10 = 2;    // PULL_RES
     29              PINMODE0_bit.P0_11 = 2;    //
     30          
     31              // Init module I2C2
     32              I2C2SCLH_bit.SCLH = 80;   // Freq 28,8 Mhz / (40 + 40)
     33              I2C2SCLL_bit.SCLL = 80;
     34          
     35              I2C2CONCLR = I2C_AA;       // master mode
     36              I2C2CONCLR = I2C_SI;
     37              I2C2CONCLR = I2C_STA;
     38          
     39              I2C2CONSET = I2C_EN;
     40          }
     41          
     42          
     43          /*
     44           * Start transaction i2c2
     45           *
     46           */
     47          int start_i2c2(void * _pt, i2c_data * _pData) {
     48              // Thread
     49              PT_BEGIN((struct pt *)_pt);
     50          
     51              // Prepare
     52              pData = _pData;
     53              _pData->ind = 0UL;
     54              _pData->isEnd = FALSE_T;
     55              _pData->isOk = FALSE_T;
     56          
     57              I2C2CONSET = I2C_STA;
     58          
     59              PT_WAIT_UNTIL((struct pt *)_pt, _pData->isEnd);
     60          
     61              PT_END((struct pt *)_pt);
     62          }
     63          
     64          
     65          
     66          
     67          /*
     68           * Int handler
     69           *
     70           */
     71          __irq __arm void __interrupt_handler_i2c2() {
     72              __eSTATUS_I2C status = (__eSTATUS_I2C)I2C2STAT;
     73          
     74              switch (status)
     75              {
     76                  //----------------------------------------------------------------------
     77                  case eI2C_08:
     78                    //DEBUG_PRINTF("\r\n\r\n08_2");
     79                    I2C2DAT = pData->addr;
     80                    I2C2CONCLR = I2C_STA;
     81          
     82                    if (pData->ind >= pData->len) {
     83                        I2C2CONSET = I2C_STO;
     84                        pData->isEnd = TRUE_T;
     85                    };
     86                  break;
     87          
     88                  //----------------------------------------------------------------------
     89                  case eI2C_10:
     90                    //DEBUG_PRINTF("\r\n10_2");
     91                    pData->ind = 0;
     92                    I2C2DAT = pData->addr;
     93                    I2C2CONCLR = I2C_STA;
     94                  break;
     95          
     96                  //----------------------------------------------------------------------
     97                  case eI2C_18:
     98                    //DEBUG_PRINTF("\r\n18_2");
     99                    I2C2DAT = pData->buff[pData->ind++];
    100                  break;
    101          
    102                  //----------------------------------------------------------------------
    103                  case eI2C_20:
    104                    //DEBUG_PRINTF("\r\n20_2");
    105                    I2C2CONSET = I2C_STO;
    106                    pData->isEnd = TRUE_T;
    107                   break;
    108          
    109                  //----------------------------------------------------------------------
    110                  case eI2C_28:
    111                    //DEBUG_PRINTF("\r\n28_2");
    112                    if (pData->ind == pData->len) {
    113                        I2C2CONSET = I2C_STO;
    114                        pData->isEnd = TRUE_T;
    115                        pData->isOk = TRUE_T;
    116                    }
    117                    else {
    118                        I2C2DAT = pData->buff[pData->ind++];
    119                    };
    120                  break;
    121          
    122                  //----------------------------------------------------------------------
    123                  case eI2C_30:
    124                    //DEBUG_PRINTF("\r\n30_2");
    125                    I2C2CONSET = I2C_STO;
    126                    pData->isEnd = TRUE_T;
    127                  break;
    128          
    129                  //----------------------------------------------------------------------
    130                  case eI2C_38:
    131                    //DEBUG_PRINTF("\r\n38_2");
    132                    I2C2CONSET = I2C_STA;
    133                  break;
    134          
    135                  //----------------------------------------------------------------------
    136                  case eI2C_40:
    137                    //DEBUG_PRINTF("\r\n40_2");
    138                    I2C2CONSET = I2C_AA;
    139                  break;
    140          
    141                  //----------------------------------------------------------------------
    142                  case eI2C_48:
    143                    //DEBUG_PRINTF("\r\n48_2");
    144                    I2C2CONSET = I2C_STO;
    145                    pData->isEnd = TRUE_T;
    146                  break;
    147          
    148                  //----------------------------------------------------------------------
    149                  case eI2C_50:
    150                    //DEBUG_PRINTF("\r\n50_2");
    151                    pData->buff[pData->ind++] = I2C2DAT;
    152                    if (pData->ind == pData->len) {
    153                        I2C2CONCLR = I2C_AA;
    154                    }
    155                    else {
    156                        I2C2CONSET = I2C_AA;
    157                    };
    158                  break;
    159          
    160                  //----------------------------------------------------------------------
    161                  case eI2C_58:
    162                    //DEBUG_PRINTF("\r\n58_2");
    163                    I2C2CONSET = I2C_STO;
    164                    pData->isEnd = TRUE_T;
    165                    pData->isOk = TRUE_T;
    166                  break;
    167          
    168                  //----------------------------------------------------------------------
    169                  default:
    170                    I2C2CONSET = I2C_STO;
    171                    pData->isEnd = TRUE_T;
    172                  break;
    173              };
    174          
    175              I2C2CONCLR = I2C_SI;
    176              VICADDRESS = 0;
    177          }

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     __interrupt_handler_i2c2     16
     init_i2c2                    16
     start_i2c2                    4


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     _A_PCONP                    4
     VICADDRESS                  4
     _A_PINSEL0                  4
     _A_PINMODE0                 4
     _A_I2C2CONSET               4
     _A_I2C2STAT                 4
     _A_I2C2DAT                  4
     _A_I2C2SCLH                 4
     _A_I2C2SCLL                 4
     _A_I2C2CONCLR               4
     pData                       4
     init_i2c2                 100
     start_i2c2                 52
     __interrupt_handler_i2c2  412
     ??DataTable2                4
     ??DataTable2_1              4
     ??DataTable2_2              4
     ??DataTable2_3              4
     ??DataTable2_4              4
     ??DataTable2_5              4
     ??DataTable2_6              4

 
   4 bytes in section .bss
  40 bytes in section .data
 592 bytes in section .text
 
 592 bytes of CODE memory
   4 bytes of DATA memory (+ 40 bytes shared)

Errors: none
Warnings: none
