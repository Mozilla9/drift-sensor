###############################################################################
#                                                                             #
#                                                       08/Oct/2012  01:42:16 #
# IAR ANSI C/C++ Compiler V6.21.2.22939/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Projects\google_host\drift-sensor\Lis3dh\lis3dh.c     #
#    Command line =  D:\Projects\google_host\drift-sensor\Lis3dh\lis3dh.c -D  #
#                    NDEBUG -lc D:\Projects\google_host\drift-sensor\Release\ #
#                    List\ --diag_suppress Pe550 -o                           #
#                    D:\Projects\google_host\drift-sensor\Release\Obj\        #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --endian=little --cpu=ARM7TDMI-S -e --fpu=None           #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    D:\Projects\google_host\drift-sensor\ -I                 #
#                    D:\Projects\google_host\drift-sensor\Config\             #
#                    --interwork --cpu_mode thumb -Om                         #
#    List file    =  D:\Projects\google_host\drift-sensor\Release\List\lis3dh #
#                    .lst                                                     #
#    Object file  =  D:\Projects\google_host\drift-sensor\Release\Obj\lis3dh. #
#                    o                                                        #
#                                                                             #
#                                                                             #
###############################################################################

D:\Projects\google_host\drift-sensor\Lis3dh\lis3dh.c
      1          /******************************************************************************/
      2          /* lis3dh.c                                                                   */
      3          /******************************************************************************/
      4          
      5          
      6          #include "data_types.h"
      7          #include <math.h>
      8          #include "Protothread\pt.h"
      9          #include "Core\core.h"
     10          #include "I2c\i2c0.h"
     11          #include "Lis3dh\lis3dh.h"
     12          
     13          
     14          
     15          
     16          static vector a;              // accelerometer readings
     17          static i2c_data a_data;
     18          static struct pt a_pt;
     19          
     20          #define ACC_ADDRESS_W (ACC_ADDRESS & I2C_WRITE)
     21          #define ACC_ADDRESS_R (ACC_ADDRESS | I2C_READ)
     22          
     23          
     24          
     25          
     26          /*
     27           * Writes an accelerometer register
     28           *
     29           */
     30          static void write_acc_reg(const uint8_t reg, const uint8_t value) {
     31              a_data.addr = ACC_ADDRESS_W;
     32              a_data.buff[0] = reg;
     33              a_data.buff[1] = value;
     34              a_data.len = 2;
     35          
     36              PT_INIT(&a_pt);
     37              while (1) {
     38                  uint32_t status = start_i2c0(&a_pt, &a_data);
     39          
     40                  if (status == PT_ENDED || status == PT_EXITED) {
     41                      break;
     42                  }
     43              }
     44          }
     45          
     46          
     47          /*
     48           * Init interrupt pins
     49           *
     50           */
     51          static void init_interrupt_pins() {
     52              // Init int
     53              PINSEL4_bit.P2_11 = 0;     // int1
     54              PINSEL4_bit.P2_12 = 0;     // int2
     55          
     56              FIO2DIR_bit.P2_11 = 0;     // input
     57              FIO2DIR_bit.P2_12 = 0;     // input
     58          
     59              PINMODE4_bit.P2_11 = 3;    // PULL_RES
     60              PINMODE4_bit.P2_12 = 3;    //
     61          
     62          }
     63          
     64          /*
     65           * Init CS
     66           *
     67           */
     68          static void init_cs() {
     69              // Init int
     70              PINSEL7_bit.P3_25 = 0;    // cs
     71              FIO3DIR_bit.P3_25 = 1;    // output
     72              PINMODE7_bit.P3_25 = 3;   // PULL_RES
     73          }
     74          
     75          
     76          /*
     77           * Init SA0
     78           *
     79           */
     80          static void init_addr() {
     81              // Init int
     82              PINSEL7_bit.P3_26 = 0;    // sa0
     83              FIO3DIR_bit.P3_26 = 1;    // output
     84              PINMODE7_bit.P3_26 = 3;   // PULL_RES
     85          }
     86          
     87          
     88          /*
     89           * get int1
     90           *
     91           */
     92          bool_t get_int1_lis3dh() {
     93              return (FIO2PIN_bit.P2_11) ? TRUE_T : FALSE_T;
     94          }
     95          
     96          
     97          /*
     98           * get int2
     99           *
    100           */
    101          bool_t get_int2_lis3dh() {
    102              return (FIO2PIN_bit.P2_12) ? TRUE_T : FALSE_T;
    103          }
    104          
    105          
    106          /*
    107           * Set SA0
    108           *
    109           */
    110          void set_sa0_lis3dh() {
    111              FIO3SET_bit.P3_26 = 1;
    112          }
    113          
    114          
    115          /*
    116           * Clear SA0
    117           *
    118           */
    119          void clear_sa0_lis3dh() {
    120              FIO3CLR_bit.P3_26 = 1;
    121          }
    122          
    123          
    124          /*
    125           * Set cs
    126           *
    127           */
    128          void set_cs_lis3dh() {
    129              FIO3SET_bit.P3_25 = 1;
    130          }
    131          
    132          
    133          /*
    134           * Clear cs
    135           *
    136           */
    137          void clear_cs_lis3dh() {
    138              FIO3CLR_bit.P3_25 = 1;
    139          }
    140          
    141          
    142          /*
    143           * Init lis3dh
    144           *
    145           */
    146          void init_lis3dh() {
    147              init_i2c0();
    148              init_interrupt_pins();
    149              init_addr();
    150              init_cs();
    151          
    152              set_sa0_lis3dh();  // slave addr 0x0011001
    153              set_cs_lis3dh();   // sel i2c
    154          }
    155          
    156          
    157          /*
    158           * Turns on the lis3dh's accelerometer and place
    159           * it in normal mode.
    160           *
    161           */
    162          void enable_default_lis3dh() {
    163              // Enable Accelerometer
    164              write_acc_reg(LIS3DH_TEMP_CFG_REG, 0x00);  // adc dis, temp sensor dis
    165              write_acc_reg(LIS3DH_CTRL_REG1, 0x57);     // 100 Hz, normal mode, all axis en
    166              write_acc_reg(LIS3DH_CTRL_REG4, 0x10);     // 4g
    167          }
    168          
    169          
    170          /*
    171           * Reads the 3 accelerometer channels and stores them in vector a
    172           *
    173           */
    174          void read_acc_lis3dh() {
    175              // Write reg addr
    176              a_data.addr = ACC_ADDRESS_W;
    177              a_data.buff[0] = (LIS3DH_OUT_X_L | (1 << 7));
    178              a_data.len = 1;
    179          
    180              PT_INIT(&a_pt);
    181              while (1) {
    182                  uint32_t status = start_i2c0(&a_pt, &a_data);
    183          
    184                  if (status == PT_ENDED || status == PT_EXITED) {
    185                      break;
    186                  }
    187              }
    188          
    189              // Read
    190              a_data.addr = ACC_ADDRESS_R;
    191              a_data.len = 6;
    192          
    193              PT_INIT(&a_pt);
    194              while (1) {
    195                  uint32_t status = start_i2c0(&a_pt, &a_data);
    196          
    197                  if (status == PT_ENDED || status == PT_EXITED) {
    198                      break;
    199                  }
    200              }
    201          
    202              uint8_t xla = a_data.buff[0];
    203              uint8_t xha = a_data.buff[1];
    204              uint8_t yla = a_data.buff[2];
    205              uint8_t yha = a_data.buff[3];
    206              uint8_t zla = a_data.buff[4];
    207              uint8_t zha = a_data.buff[5];
    208          
    209              a.x = (sint16_t)((xha << 8) | (xla & 0xFF));
    210              a.y = (sint16_t)((yha << 8) | (yla & 0xFF));
    211              a.z = (sint16_t)((zha << 8) | (zla & 0xFF));
    212          
    213              a.status = a_data.isOk;
    214          }
    215          
    216          
    217          /*
    218           * Get acc vector
    219           *
    220           */
    221          vector * get_acc_lis3dh() {
    222              return &a;
    223          }

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     clear_cs_lis3dh            0
     clear_sa0_lis3dh           0
     enable_default_lis3dh      8
     get_acc_lis3dh             0
     get_int1_lis3dh            0
     get_int2_lis3dh            0
     init_addr                  0
     init_cs                    0
     init_interrupt_pins        0
     init_lis3dh                8
     read_acc_lis3dh           24
     set_cs_lis3dh              0
     set_sa0_lis3dh             0
     write_acc_reg              8


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     _A_PINSEL4               4
     _A_PINSEL7               4
     _A_PINMODE4              4
     _A_PINMODE7              4
     _A_FIO2DIR               4
     _A_FIO2PIN               4
     _A_FIO3DIR               4
     _A_FIO3SET               4
     _A_FIO3CLR               4
     a                       12
     a_data                  56
     a_pt
     write_acc_reg           46
     init_interrupt_pins     58
     init_cs                 34
     init_addr               34
     get_int1_lis3dh         12
     get_int2_lis3dh         12
     set_sa0_lis3dh          14
     clear_sa0_lis3dh        14
     set_cs_lis3dh           14
     clear_cs_lis3dh         14
     init_lis3dh             30
     enable_default_lis3dh   30
     read_acc_lis3dh        112
     get_acc_lis3dh           4
     ??DataTable11            4
     ??DataTable11_1          4
     ??DataTable11_2          4
     ??DataTable11_3          4
     ??DataTable11_4          4
     ??DataTable11_5          4
     ??DataTable11_6          4
     ??DataTable11_7          4
     ??DataTable11_8          4
     ??DataTable11_9          4
     ??DataTable11_10         4
     ??DataTable11_11         4
     ??DataTable11_12         4
     ??DataTable11_13         4
     ??DataTable11_14         4

 
  68 bytes in section .bss
  36 bytes in section .data
 488 bytes in section .text
 
 488 bytes of CODE memory
  68 bytes of DATA memory (+ 36 bytes shared)

Errors: none
Warnings: none
