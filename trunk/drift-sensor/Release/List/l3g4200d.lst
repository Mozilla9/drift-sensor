###############################################################################
#                                                                             #
#                                                       07/Oct/2012  22:33:55 #
# IAR ANSI C/C++ Compiler V6.21.2.22939/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Projects\google_host\drift-sensor\L3g4200d\l3g4200d.c #
#    Command line =  D:\Projects\google_host\drift-sensor\L3g4200d\l3g4200d.c #
#                     -D NDEBUG -lc D:\Projects\google_host\drift-sensor\Rele #
#                    ase\List\ --diag_suppress Pe550 -o                       #
#                    D:\Projects\google_host\drift-sensor\Release\Obj\        #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --endian=little --cpu=ARM7TDMI-S -e --fpu=None           #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    D:\Projects\google_host\drift-sensor\ -I                 #
#                    D:\Projects\google_host\drift-sensor\Config\             #
#                    --interwork --cpu_mode thumb -Om                         #
#    List file    =  D:\Projects\google_host\drift-sensor\Release\List\l3g420 #
#                    0d.lst                                                   #
#    Object file  =  D:\Projects\google_host\drift-sensor\Release\Obj\l3g4200 #
#                    d.o                                                      #
#                                                                             #
#                                                                             #
###############################################################################

D:\Projects\google_host\drift-sensor\L3g4200d\l3g4200d.c
      1          /******************************************************************************/
      2          /* l3g4200d.c                                                                 */
      3          /******************************************************************************/
      4          
      5          
      6          #include "data_types.h"
      7          #include <math.h>
      8          #include "Protothread\pt.h"
      9          #include "Core\core.h"
     10          #include "I2c\i2c0.h"
     11          #include "L3g4200d\l3g4200d.h"
     12          
     13          
     14          static gyro_angles gyro;
     15          static i2c_data g_data;
     16          static struct pt g_pt;
     17          
     18          
     19          
     20          
     21          
     22          /*
     23           * Writes an gyro register
     24           *
     25           */
     26          static void write_gyro_reg(uint8_t reg, uint8_t value) {
     27              g_data.addr = L3G4200D_DEV_ADDR_W;
     28              g_data.buff[0] = reg;
     29              g_data.buff[1] = value;
     30              g_data.len = 2;
     31          
     32              PT_INIT(&g_pt);
     33              while (1) {
     34                  uint32_t status = start_i2c0(&g_pt, &g_data);
     35          
     36                  if (status == PT_ENDED || status == PT_EXITED) {
     37                      break;
     38                  }
     39              }
     40          }
     41          
     42          
     43          /*
     44           * Reads an gyro register
     45           *
     46           */
     47          static uint8_t read_gyro_reg(uint8_t reg) {
     48              // Write reg addr
     49              g_data.addr = L3G4200D_DEV_ADDR_W;
     50              g_data.buff[0] = reg;
     51              g_data.len = 1;
     52          
     53              PT_INIT(&g_pt);
     54              while (1) {
     55                  uint32_t status = start_i2c0(&g_pt, &g_data);
     56          
     57                  if (status == PT_ENDED || status == PT_EXITED) {
     58                      break;
     59                  }
     60              }
     61          
     62              // Read
     63              g_data.addr = L3G4200D_DEV_ADDR_R;
     64              g_data.buff[0] = 0xff;
     65              g_data.len = 1;
     66          
     67              PT_INIT(&g_pt);
     68              while (1) {
     69                  uint32_t status = start_i2c0(&g_pt, &g_data);
     70          
     71                  if (status == PT_ENDED || status == PT_EXITED) {
     72                      break;
     73                  }
     74              }
     75          
     76              return g_data.buff[0];
     77          }
     78          
     79          
     80          
     81          /*
     82           * Init interrupt pins
     83           *
     84           */
     85          static void init_interrupt_pins() {
     86              // Init int
     87              PINSEL4_bit.P2_10 = 0;     // int1
     88              PINSEL4_bit.P2_11 = 0;     // int2
     89          
     90              FIO2DIR_bit.P2_10 = 0;     // input
     91              FIO2DIR_bit.P2_11 = 0;     // input
     92          
     93              PINMODE4_bit.P2_10 = 3;    // PULL_RES
     94              PINMODE4_bit.P2_11 = 3;    //
     95          
     96          }
     97          
     98          
     99          /*
    100           * Init spi-pins
    101           *
    102           */
    103          static void init_spi() {
    104              PINSEL0_bit.P0_6 = 0;
    105              PINSEL0_bit.P0_7 = 0;
    106              PINSEL0_bit.P0_8 = 0;
    107              PINSEL0_bit.P0_9 = 0;
    108          
    109              FIO0DIR_bit.P0_6 = 0;
    110              FIO0DIR_bit.P0_7 = 0;
    111              FIO0DIR_bit.P0_8 = 0;
    112              FIO0DIR_bit.P0_9 = 0;
    113          
    114              PINMODE0_bit.P0_6 = 0;    // PULL_RES
    115              PINMODE0_bit.P0_7 = 0;    // PULL_RES
    116              PINMODE0_bit.P0_8 = 0;    // PULL_RES
    117              PINMODE0_bit.P0_9 = 0;    // PULL_RES
    118          }
    119          
    120          
    121          /*
    122           * Init SA0
    123           *
    124           */
    125          static void init_addr() {
    126              // Init int
    127              PINSEL7_bit.P3_26 = 0;    // sa0
    128              FIO3DIR_bit.P3_26 = 1;    // output
    129              PINMODE7_bit.P3_26 = 3;   // PULL_RES
    130          }
    131          
    132          
    133          /*
    134           * get int1
    135           *
    136           */
    137          bool_t get_int1_gyro() {
    138              return (FIO2PIN_bit.P2_10) ? TRUE_T : FALSE_T;
    139          }
    140          
    141          
    142          /*
    143           * get int2
    144           *
    145           */
    146          bool_t get_int2_gyro() {
    147              return (FIO2PIN_bit.P2_11) ? TRUE_T : FALSE_T;
    148          }
    149          
    150          
    151          /*
    152           * Set SA0
    153           *
    154           */
    155          void set_sa0_gyro() {
    156              FIO3SET_bit.P3_26 = 1;
    157          }
    158          
    159          
    160          /*
    161           * Clear SA0
    162           *
    163           */
    164          void clear_sa0_gyro() {
    165              FIO3CLR_bit.P3_26 = 1;
    166          }
    167          
    168          
    169          /*
    170           * Init L3G4200D
    171           *
    172           */
    173          void init_l3g4200d() {
    174              init_addr();
    175              init_spi();
    176              init_interrupt_pins();
    177              init_i2c0();
    178          
    179              set_sa0_gyro();
    180          }
    181          
    182          
    183          /*
    184           * Find gyro
    185           *
    186           */
    187          void enable_default_l3g4200d() {
    188              uint8_t id = read_gyro_reg(L3G4000D_WHO_I_AM_REG);
    189              write_gyro_reg(L3G4000D_CTRL_REG1, 0x0F);
    190          }
    191          
    192          
    193          /*
    194           * Reads the 3 gyro channels and stores them in data struct
    195           *
    196           */
    197          void read_gyro() {
    198              // Write reg addr
    199              g_data.addr = L3G4200D_DEV_ADDR_W;
    200              g_data.buff[0] = L3G4000D_OUT_X_L;
    201              g_data.len = 1;
    202          
    203              PT_INIT(&g_pt);
    204              while (1) {
    205                  uint32_t status = start_i2c0(&g_pt, &g_data);
    206          
    207                  if (status == PT_ENDED || status == PT_EXITED) {
    208                      break;
    209                  }
    210              }
    211          
    212              // Read
    213              g_data.addr = L3G4200D_DEV_ADDR_R;
    214              g_data.len = 6;
    215          
    216              PT_INIT(&g_pt);
    217              while (1) {
    218                  uint32_t status = start_i2c0(&g_pt, &g_data);
    219          
    220                  if (status == PT_ENDED || status == PT_EXITED) {
    221                      break;
    222                  }
    223              }
    224          
    225              uint8_t xla = g_data.buff[0];
    226              uint8_t xha = g_data.buff[1];
    227              uint8_t yla = g_data.buff[2];
    228              uint8_t yha = g_data.buff[3];
    229              uint8_t zla = g_data.buff[4];
    230              uint8_t zha = g_data.buff[5];
    231          
    232              gyro.x = (xha << 8 | xla);
    233              gyro.y = (yha << 8 | yla);
    234              gyro.z = (zha << 8 | zla);
    235          
    236              gyro.status = g_data.isOk;
    237          }
    238          
    239          
    240          /*
    241           * Get temp
    242           *
    243           */
    244          uint8_t get_gyro_temp(){
    245              return read_gyro_reg(L3G4000D_OUT_TEMP);
    246          }
    247          
    248          
    249          /*
    250           * Get gyro data
    251           *
    252           */
    253          gyro_angles * get_gyro() {
    254              return &gyro;
    255          }

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     clear_sa0_gyro               0
     enable_default_l3g4200d      8
     get_gyro                     0
     get_gyro_temp                8
     get_int1_gyro                0
     get_int2_gyro                0
     init_addr                    0
     init_interrupt_pins          0
     init_l3g4200d                8
     init_spi                    16
     read_gyro                   24
     read_gyro_reg               16
     set_sa0_gyro                 0
     write_gyro_reg               8


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _A_PINSEL0                 4
     _A_PINSEL4                 4
     _A_PINSEL7                 4
     _A_PINMODE0                4
     _A_PINMODE4                4
     _A_PINMODE7                4
     _A_FIO0DIR                 4
     _A_FIO2DIR                 4
     _A_FIO2PIN                 4
     _A_FIO3DIR                 4
     _A_FIO3SET                 4
     _A_FIO3CLR                 4
     gyro                      12
     g_data                    56
     g_pt
     write_gyro_reg            46
     read_gyro_reg             78
     init_interrupt_pins       58
     init_spi                  98
     init_addr                 34
     get_int1_gyro             12
     get_int2_gyro             12
     set_sa0_gyro              14
     clear_sa0_gyro            14
     init_l3g4200d             26
     enable_default_l3g4200d   20
     read_gyro                112
     get_gyro_temp             12
     get_gyro                   4
     ??DataTable10              4
     ??DataTable10_1            4
     ??DataTable10_2            4
     ??DataTable10_3            4
     ??DataTable10_4            4
     ??DataTable10_5            4
     ??DataTable10_6            4
     ??DataTable10_7            4
     ??DataTable10_8            4
     ??DataTable10_9            4
     ??DataTable10_10           4
     ??DataTable10_11           4
     ??DataTable10_12           4
     ??DataTable10_13           4
     ??DataTable10_14           4
     ??DataTable10_15           4
     ??DataTable10_16           4
     ??DataTable10_17           4
     ??DataTable10_18           4
     ??DataTable10_19           4
     ??DataTable10_20           4

 
  68 bytes in section .bss
  48 bytes in section .data
 624 bytes in section .text
 
 624 bytes of CODE memory
  68 bytes of DATA memory (+ 48 bytes shared)

Errors: none
Warnings: none
