###############################################################################
#                                                                             #
#                                                       08/Oct/2012  01:42:19 #
# IAR ANSI C/C++ Compiler V6.21.2.22939/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Projects\google_host\drift-sensor\Microrl\microrl.c   #
#    Command line =  D:\Projects\google_host\drift-sensor\Microrl\microrl.c   #
#                    -D NDEBUG -lc D:\Projects\google_host\drift-sensor\Relea #
#                    se\List\ --diag_suppress Pe550 -o                        #
#                    D:\Projects\google_host\drift-sensor\Release\Obj\        #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --endian=little --cpu=ARM7TDMI-S -e --fpu=None           #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    D:\Projects\google_host\drift-sensor\ -I                 #
#                    D:\Projects\google_host\drift-sensor\Config\             #
#                    --interwork --cpu_mode thumb -Om                         #
#    List file    =  D:\Projects\google_host\drift-sensor\Release\List\micror #
#                    l.lst                                                    #
#    Object file  =  D:\Projects\google_host\drift-sensor\Release\Obj\microrl #
#                    .o                                                       #
#                                                                             #
#                                                                             #
###############################################################################

D:\Projects\google_host\drift-sensor\Microrl\microrl.c
      1          /******************************************************************************/
      2          /* microrl.c                                                                  */
      3          /*                                                                            */
      4          /*    Author: Samoylov Eugene aka Helius (ghelius@gmail.com)                  */
      5          /*    BUGS and TODO:                                                          */
      6          /*    -- add echo_off feature                                                 */
      7          /*    -- rewrite history for use more than 256 byte buffer                    */
      8          /*                                                                            */
      9          /******************************************************************************/
     10          
     11          #include <string.h>
     12          #include "data_types.h"
     13          #include "microrl.h"
     14          
     15          
     16          
     17          static microrl_t rl;
     18          microrl_t * pointerMicrorl = &rl;
     19          int8_t * prompt_default = _PROMPT_DEFAULT;
     20          
     21          #ifdef _USE_HISTORY
     22          
     23          #ifdef _HISTORY_DEBUG
     24          //*****************************************************************************
     25          // print buffer content on screen
     26          static void print_hist (ring_history_t * pThis)
     27          {
     28              pThis->print ("\n");
     29              for (int32_t i = 0; i < _RING_HISTORY_LEN; i++) {
     30                  if (i == pThis->begin)
     31                      pThis->print ("b");
     32                  else
     33                      pThis->print (" ");
     34              }
     35              pThis->print ("\n");
     36              for (int32_t i = 0; i < _RING_HISTORY_LEN; i++) {
     37                  if (isalpha(pThis->ring_buf[i]))
     38                      pThis->print ("%c", pThis->ring_buf[i]);
     39                  else
     40                      pThis->print ("%d", pThis->ring_buf[i]);
     41              }
     42              pThis->print ("\n");
     43              for (int32_t i = 0; i < _RING_HISTORY_LEN; i++) {
     44                  if (i == pThis->end)
     45                      pThis->print ("e");
     46                  else
     47                      pThis->print (" ");
     48              }
     49              pThis->print ("\n");
     50          }
     51          #endif
     52          
     53          //*****************************************************************************
     54          // fake printf for prodaction 21-09-2012
     55          static uint32_t fake_serprintf(const int8_t * format, ...) 
     56          { 
     57              return 0; 
     58          }
     59          
     60          //*****************************************************************************
     61          // remove older message from ring buffer
     62          static void hist_erase_older (ring_history_t * pThis)
     63          {
     64              int32_t new_pos = pThis->begin + pThis->ring_buf [pThis->begin] + 1;
     65              if (new_pos >= _RING_HISTORY_LEN)
     66                  new_pos = new_pos - _RING_HISTORY_LEN;
     67          
     68              pThis->begin = new_pos;
     69          }
     70          
     71          //*****************************************************************************
     72          // check space for new line, remove older while not space
     73          static int32_t hist_is_space_for_new (ring_history_t * pThis, int32_t len)
     74          {
     75              if (pThis->ring_buf [pThis->begin] == 0)
     76                  return true;
     77              if (pThis->end >= pThis->begin) {
     78                  if (_RING_HISTORY_LEN - pThis->end + pThis->begin - 1 > len)
     79                      return true;
     80              }    else {
     81                  if (pThis->begin - pThis->end - 1> len)
     82                      return true;
     83              }
     84              return false;
     85          }
     86          
     87          //*****************************************************************************
     88          // put line to ring buffer
     89          static void hist_save_line (ring_history_t * pThis, int8_t * line, int32_t len)
     90          {
     91              if (len > _RING_HISTORY_LEN - 2)
     92                  return;
     93              while (!hist_is_space_for_new (pThis, len)) {
     94                  hist_erase_older (pThis);
     95              }
     96              // if it's first line
     97              if (pThis->ring_buf [pThis->begin] == 0)
     98                  pThis->ring_buf [pThis->begin] = len;
     99          
    100              // store line
    101              if (len < _RING_HISTORY_LEN-pThis->end-1)
    102                  memcpy (pThis->ring_buf + pThis->end + 1, line, len);
    103              else {
    104                  int32_t part_len = _RING_HISTORY_LEN-pThis->end-1;
    105                  memcpy (pThis->ring_buf + pThis->end + 1, line, part_len);
    106                  memcpy (pThis->ring_buf, line + part_len, len - part_len);
    107              }
    108              pThis->ring_buf [pThis->end] = len;
    109              pThis->end = pThis->end + len + 1;
    110              if (pThis->end >= _RING_HISTORY_LEN)
    111                  pThis->end -= _RING_HISTORY_LEN;
    112              pThis->ring_buf [pThis->end] = 0;
    113              pThis->cur = 0;
    114          #ifdef _HISTORY_DEBUG
    115              print_hist (pThis);
    116          #endif
    117          }
    118          
    119          //*****************************************************************************
    120          // copy saved line to 'line' and return size of line
    121          static int32_t hist_restore_line (ring_history_t * pThis, int8_t * line, int32_t dir)
    122          {
    123              int32_t cnt = 0;
    124              // count history record
    125              int32_t header = pThis->begin;
    126              while (pThis->ring_buf [header] != 0) {
    127                  header += pThis->ring_buf [header] + 1;
    128                  if (header >= _RING_HISTORY_LEN)
    129                      header -= _RING_HISTORY_LEN;
    130                  cnt++;
    131              }
    132          
    133              if (dir == _HIST_UP) {
    134                  if (cnt >= pThis->cur) {
    135                      int32_t header = pThis->begin;
    136                      int32_t j = 0;
    137                      // found record for 'pThis->cur' index
    138                      while ((pThis->ring_buf [header] != 0) && (cnt - j -1 != pThis->cur)) {
    139                          header += pThis->ring_buf [header] + 1;
    140                          if (header >= _RING_HISTORY_LEN)
    141                              header -= _RING_HISTORY_LEN;
    142                          j++;
    143                      }
    144                      if (pThis->ring_buf[header]) {
    145                              pThis->cur++;
    146                          // obtain saved line
    147                          if (pThis->ring_buf [header] + header < _RING_HISTORY_LEN) {
    148                              memcpy (line, pThis->ring_buf + header + 1, pThis->ring_buf[header]);
    149                          } else {
    150                              int32_t part0 = _RING_HISTORY_LEN - header - 1;
    151                              memcpy (line, pThis->ring_buf + header + 1, part0);
    152                              memcpy (line + part0, pThis->ring_buf, pThis->ring_buf[header] - part0);
    153                          }
    154                          return pThis->ring_buf[header];
    155                      }
    156                  }
    157              } else {
    158                  if (pThis->cur > 0) {
    159                          pThis->cur--;
    160                      int32_t header = pThis->begin;
    161                      int32_t j = 0;
    162          
    163                      while ((pThis->ring_buf [header] != 0) && (cnt - j != pThis->cur)) {
    164                          header += pThis->ring_buf [header] + 1;
    165                          if (header >= _RING_HISTORY_LEN)
    166                              header -= _RING_HISTORY_LEN;
    167                          j++;
    168                      }
    169                      if (pThis->ring_buf [header] + header < _RING_HISTORY_LEN) {
    170                          memcpy (line, pThis->ring_buf + header + 1, pThis->ring_buf[header]);
    171                      } else {
    172                          int32_t part0 = _RING_HISTORY_LEN - header - 1;
    173                          memcpy (line, pThis->ring_buf + header + 1, part0);
    174                          memcpy (line + part0, pThis->ring_buf, pThis->ring_buf[header] - part0);
    175                      }
    176                      return pThis->ring_buf[header];
    177                  }
    178              }
    179              return 0;
    180          }
    181          #endif
    182          
    183          
    184          
    185          
    186          
    187          
    188          
    189          
    190          //*****************************************************************************
    191          // split cmdline to tkn array and return nmb of token
    192          static int32_t split (microrl_t * pThis, int32_t limit)
    193          {
    194              int32_t i = 0;
    195              int32_t ind = 0;
    196              while (1) {
    197                  // go to the first whitespace (zerro for us)
    198                  while ((pThis->cmdline [ind] == '\0') && (ind < limit)) {
    199                      ind++;
    200                  }
    201                  if (!(ind < limit)) return i;
    202                  pThis->tkn_arr[i++] = pThis->cmdline + ind;
    203                  if (i >= _COMMAND_TOKEN_NMB) {
    204                      return -1;
    205                  }
    206                  // go to the first NOT whitespace (not zerro for us)
    207                  while ((pThis->cmdline [ind] != '\0') && (ind < limit)) {
    208                      ind++;
    209                  }
    210                  if (!(ind < limit)) return i;
    211              }
    212          }
    213          
    214          
    215          //*****************************************************************************
    216          inline static void print_prompt (microrl_t * pThis)
    217          {
    218              pThis->print (pThis->prompt_str);
    219          }
    220          
    221          //*****************************************************************************
    222          inline static void terminal_backspace (microrl_t * pThis)
    223          {
    224              pThis->print ("\033[D \033[D");
    225          }
    226          
    227          //*****************************************************************************
    228          inline static void terminal_newline (microrl_t * pThis)
    229          {
    230              pThis->print (ENDL);
    231          }
    232          
    233          #ifndef _USE_LIBC_STDIO
    234          //*****************************************************************************
    235          // convert 16 bit value to string
    236          // 0 value not supported!!! just make empty string
    237          static void u16bit_to_str (uint32_t nmb, int8_t * buf)
    238          {
    239              int8_t tmp_str [6] = {0,};
    240              int32_t i = 0;
    241              if (nmb <= 0xFFFF) {
    242                  while (nmb > 0) {
    243                      tmp_str[i++] = (nmb % 10) + '0';
    244                      nmb /=10;
    245                  }
    246                  for (int32_t j = 0; j < i; ++j)
    247                      *(buf++) = tmp_str [i-j-1];
    248              }
    249              *buf = '\0';
    250          }
    251          #endif
    252          
    253          
    254          //*****************************************************************************
    255          // set cursor at position from begin cmdline (after prompt) + offset
    256          static void terminal_move_cursor (microrl_t * pThis, int32_t offset)
    257          {
    258              int8_t str[16] = {0,};
    259          #ifdef _USE_LIBC_STDIO
    260              if (offset > 0) {
    261                  snprintf (str, 16, "\033[%dC", offset);
    262              } else if (offset < 0) {
    263                  snprintf (str, 16, "\033[%dD", -(offset));
    264              }
    265          #else
    266              strcpy (str, "\033[");
    267              if (offset > 0) {
    268                  u16bit_to_str (offset, str+2);
    269                  strcat (str, "C");
    270              } else if (offset < 0) {
    271                  u16bit_to_str (-(offset), str+2);
    272                  strcat (str, "D");
    273              } else
    274                  return;
    275          #endif
    276              pThis->print (str);
    277          }
    278          
    279          //*****************************************************************************
    280          static void terminal_reset_cursor (microrl_t * pThis)
    281          {
    282              int8_t str[16];
    283          #ifdef _USE_LIBC_STDIO
    284              snprintf (str, 16, "\033[%dD\033[%dC", \
    285                                  _COMMAND_LINE_LEN + _PROMPT_LEN + 2, _PROMPT_LEN);
    286          
    287          #else
    288              strcpy (str, "\033[");
    289              u16bit_to_str ( _COMMAND_LINE_LEN + _PROMPT_LEN + 2,str+2);
    290              strcat (str, "D\033[");
    291              u16bit_to_str (_PROMPT_LEN, str+strlen(str));
    292              strcat (str, "C");
    293          #endif
    294              pThis->print (str);
    295          }
    296          
    297          //*****************************************************************************
    298          // print cmdline to screen, replace '\0' to wihitespace
    299          static void terminal_print_line (microrl_t * pThis, int32_t pos, int32_t cursor)
    300          {
    301              pThis->print ("\033[K");    // delete all from cursor to end
    302          
    303              int8_t nch [] = {0,0};
    304              for (int32_t i = pos; i < pThis->cmdlen; i++) {
    305                  nch [0] = pThis->cmdline [i];
    306                  if (nch[0] == '\0')
    307                      nch[0] = ' ';
    308                  pThis->print (nch);
    309              }
    310          
    311              terminal_reset_cursor (pThis);
    312              terminal_move_cursor (pThis, cursor);
    313          }
    314          
    315          //*****************************************************************************
    316          void microrl_init (microrl_t * pThis, serprint_func f)
    317          {
    318              memset(pThis->cmdline, 0, _COMMAND_LINE_LEN);
    319          #ifdef _USE_HISTORY
    320              memset(pThis->ring_hist.ring_buf, 0, _RING_HISTORY_LEN);
    321              pThis->ring_hist.begin = 0;
    322              pThis->ring_hist.end = 0;
    323              pThis->ring_hist.cur = 0;
    324          #endif
    325              pThis->cmdlen =0;
    326              pThis->cursor = 0;
    327              pThis->execute = NULL;
    328              pThis->get_completion = NULL;
    329          #ifdef _USE_CTLR_C
    330              pThis->sigint = NULL;
    331          #endif
    332              pThis->prompt_str = prompt_default;
    333              pThis->print = f == NULL ? &fake_serprintf : f;
    334          #ifdef _ENABLE_INIT_PROMPT
    335              print_prompt (pThis);
    336          #endif
    337          }
    338          
    339          //*****************************************************************************
    340          void microrl_init_printf (microrl_t * pThis, serprint_func f)
    341          {
    342              pThis->print = f == NULL ? &fake_serprintf : f;
    343          }
    344          
    345          //*****************************************************************************
    346          serprint_func get_microrl_printf (microrl_t * pThis)
    347          {
    348              return pThis->print;
    349          }
    350          
    351          //*****************************************************************************
    352          void microrl_set_complete_callback (microrl_t * pThis, int8_t ** (*get_completion)(int32_t, const int8_t* const*))
    353          {
    354              pThis->get_completion = get_completion;
    355          }
    356          
    357          //*****************************************************************************
    358          void microrl_set_execute_callback (microrl_t * pThis, int32_t (*execute)(int32_t, const int8_t* const*))
    359          {
    360              pThis->execute = execute;
    361          }
    362          #ifdef _USE_CTLR_C
    363          //*****************************************************************************
    364          void microrl_set_sigint_callback (microrl_t * pThis, void (*sigintf)(void))
    365          {
    366              pThis->sigint = sigintf;
    367          }
    368          #endif
    369          
    370          #ifdef _USE_ESC_SEQ
    371          static void hist_search (microrl_t * pThis, int32_t dir) 
    372          {
    373              int32_t len = hist_restore_line (&pThis->ring_hist, pThis->cmdline, dir);
    374              if (len) {
    375                  pThis->cursor = pThis->cmdlen = len;
    376                  terminal_reset_cursor (pThis);
    377                  terminal_print_line (pThis, 0, pThis->cursor);
    378              }
    379          }
    380          
    381          //*****************************************************************************
    382          // handling escape sequences
    383          static int32_t escape_process (microrl_t * pThis, int8_t ch)
    384          {
    385              static int32_t seq = 0;
    386          
    387              if (ch == '[') {
    388                  seq = _ESC_BRACKET;
    389              } else if (seq == _ESC_BRACKET) {
    390                  if (ch == 'A') {
    391          #ifdef _USE_HISTORY
    392                      hist_search (pThis, _HIST_UP);
    393          #endif
    394                      return 1;
    395                  } else if (ch == 'B') {
    396          #ifdef _USE_HISTORY
    397                      hist_search (pThis, _HIST_DOWN);
    398          #endif
    399                      return 1;
    400                  } else if (ch == 'C') {
    401                      if (pThis->cursor < pThis->cmdlen) {
    402                          terminal_move_cursor (pThis, 1);
    403                          pThis->cursor++;
    404                      }
    405                      return 1;
    406                  } else if (ch == 'D') {
    407                      if (pThis->cursor > 0) {
    408                          terminal_move_cursor (pThis, -1);
    409                          pThis->cursor--;
    410                      }
    411                      return 1;
    412                  } else if (ch == '7') {
    413                      seq = _ESC_HOME;
    414                      return 0;
    415                  } else if (ch == '8') {
    416                      seq = _ESC_END;
    417                      return 0;
    418                  }
    419              } else if (ch == '~') {
    420                      if (seq == _ESC_HOME) {
    421                          terminal_reset_cursor (pThis);
    422                          pThis->cursor = 0;
    423                          return 1;
    424                      } else if (seq == _ESC_END) {
    425                          terminal_move_cursor (pThis, pThis->cmdlen-pThis->cursor);
    426                          pThis->cursor = pThis->cmdlen;
    427                          return 1;
    428                      }
    429          
    430              }
    431              return 0;
    432          }
    433          #endif
    434          
    435          //*****************************************************************************
    436          // insert len int8_t of text at cursor position
    437          static int32_t microrl_insert_text (microrl_t * pThis, int8_t * text, int32_t len)
    438          {
    439              if (pThis->cmdlen + len < _COMMAND_LINE_LEN) {
    440                  memmove (pThis->cmdline + pThis->cursor + len,
    441                                   pThis->cmdline + pThis->cursor,
    442                                   pThis->cmdlen - pThis->cursor);
    443                  for (int32_t i = 0; i < len; i++) {
    444                      pThis->cmdline [pThis->cursor + i] = text [i];
    445                      if (pThis->cmdline [pThis->cursor + i] == ' ') {
    446                          pThis->cmdline [pThis->cursor + i] = 0;
    447                      }
    448                  }
    449                  pThis->cursor += len;
    450                  pThis->cmdlen += len;
    451                  pThis->cmdline [pThis->cmdlen] = '\0';
    452                  return true;
    453              }
    454              return false;
    455          }
    456          
    457          //*****************************************************************************
    458          // remove one int8_t at cursor
    459          static void microrl_backspace (microrl_t * pThis)
    460          {
    461              if (pThis->cursor > 0) {
    462                  terminal_backspace (pThis);
    463                  memmove (pThis->cmdline + pThis->cursor-1,
    464                                   pThis->cmdline + pThis->cursor,
    465                                   pThis->cmdlen-pThis->cursor+1);
    466                  pThis->cursor--;
    467                  pThis->cmdline [pThis->cmdlen] = '\0';
    468                  pThis->cmdlen--;
    469              }
    470          }
    471          
    472          
    473          #ifdef _USE_COMPLETE
    474          
    475          //*****************************************************************************
    476          static int32_t common_len (int8_t ** arr)
    477          {
    478              int32_t len = 0;
    479              int32_t i = 1;
    480              while (1) {
    481                  while (arr[i]!=NULL) {
    482                      if ((arr[i][len] != arr[i-1][len]) ||
    483                              (arr[i][len] == '\0') ||
    484                              (arr[i-1][len]=='\0'))
    485                          return len;
    486                      len++;
    487                  }
    488                  i++;
    489              }
    490          }
    491          
    492          //*****************************************************************************
    493          static void microrl_get_complite (microrl_t * pThis)
    494          {
    495              int8_t ** compl_token;
    496          
    497              if (pThis->get_completion == NULL) // callback was not set
    498                  return;
    499          
    500              int32_t status = split (pThis, pThis->cursor);
    501              if (pThis->cmdline[pThis->cursor-1] == '\0')
    502                  pThis->tkn_arr[status++] = "";
    503              compl_token = pThis->get_completion (status, pThis->tkn_arr);
    504              if (compl_token[0] != NULL) {
    505                  int32_t i = 0;
    506                  int32_t len;
    507          
    508                  if (compl_token[1] == NULL) {
    509                      len = strlen (compl_token[0]);
    510                  } else {
    511                      len = common_len (compl_token);
    512                      terminal_newline (pThis);
    513                      while (compl_token [i] != NULL) {
    514                          pThis->print (compl_token[i]);
    515                          pThis->print (" ");
    516                          i++;
    517                      }
    518                      terminal_newline (pThis);
    519                      print_prompt (pThis);
    520                  }
    521          
    522                  if (len) {
    523                      microrl_insert_text (pThis, compl_token[0] + strlen(pThis->tkn_arr[status-1]),
    524                                                                              len - strlen(pThis->tkn_arr[status-1]));
    525                      if (compl_token[1] == NULL)
    526                          microrl_insert_text (pThis, " ", 1);
    527                  }
    528                  terminal_reset_cursor (pThis);
    529                  terminal_print_line (pThis, 0, pThis->cursor);
    530              }
    531          }
    532          #endif
    533          
    534          //*****************************************************************************
    535          void new_line_handler(microrl_t * pThis){
    536              int32_t status;
    537          
    538              terminal_newline (pThis);
    539          #ifdef _USE_HISTORY
    540              if (pThis->cmdlen > 0)
    541                  hist_save_line (&pThis->ring_hist, pThis->cmdline, pThis->cmdlen);
    542          #endif
    543              status = split (pThis, pThis->cmdlen);
    544              if (status == -1){
    545                  //          pThis->print ("ERROR: Max token amount exseed\n");
    546                  pThis->print ("ERROR:too many tokens");
    547                  pThis->print (ENDL);
    548              }
    549              if ((status > 0) && (pThis->execute != NULL))
    550                  pThis->execute (status, pThis->tkn_arr);
    551              print_prompt (pThis);
    552              pThis->cmdlen = 0;
    553              pThis->cursor = 0;
    554              memset(pThis->cmdline, 0, _COMMAND_LINE_LEN);
    555          #ifdef _USE_HISTORY
    556              pThis->ring_hist.cur = 0;
    557          #endif
    558          }
    559          
    560          //*****************************************************************************
    561          #if (defined(_ENDL_CRLF) || defined(_ENDL_LFCR))
    562              static int32_t tmpch = 0;
    563          #endif
    564          
    565          void microrl_insert_char (microrl_t * pThis, int32_t ch)
    566          {
    567              // 07-08-2012 for blank console
    568              if (ch == KEY_ETX) {
    569                  if (pThis->sigint != NULL) {
    570                      pThis->sigint();
    571                  }
    572                  return;
    573              }
    574          
    575          #ifdef _USE_ESC_SEQ
    576              static int32_t escape = false;
    577          
    578              if (escape) {
    579                  if (escape_process(pThis, ch))
    580                      escape = 0;
    581              } else {
    582          #endif
    583                  switch (ch) {
    584                      //-----------------------------------------------------
    585          #ifdef _ENDL_CR
    586                      case KEY_CR:
    587                          new_line_handler(pThis);
    588                      break;
    589                      case KEY_LF:
    590                      break;
    591          #elif defined(_ENDL_CRLF)
    592                      case KEY_CR:
    593                          tmpch = KEY_CR;
    594                      break;
    595                      case KEY_LF:
    596                      if (tmpch == KEY_CR)
    597                          new_line_handler(pThis);
    598                      break;
    599          #elif defined(_ENDL_LFCR)
    600                      case KEY_LF:
    601                          tmpch = KEY_LF;
    602                      break;
    603                      case KEY_CR:
    604                      if (tmpch == KEY_LF)
    605                          new_line_handler(pThis);
    606                      break;
    607          #else
    608                      case KEY_CR:
    609                      break;
    610                      case KEY_LF:
    611                          new_line_handler(pThis);
    612                      break;
    613          #endif
    614                      //-----------------------------------------------------
    615          #ifdef _USE_COMPLETE
    616                      case KEY_HT:
    617                          microrl_get_complite (pThis);
    618                      break;
    619          #endif
    620                      //-----------------------------------------------------
    621                      case KEY_ESC:
    622          #ifdef _USE_ESC_SEQ
    623                          escape = 1;
    624          #endif
    625                      break;
    626                      //-----------------------------------------------------
    627                      case KEY_NAK: // ^U
    628                              while (pThis->cursor > 0) {
    629                              microrl_backspace (pThis);
    630                          }
    631                          terminal_print_line (pThis, 0, pThis->cursor);
    632                      break;
    633                      //-----------------------------------------------------
    634                      case KEY_VT:  // ^K
    635                          pThis->print ("\033[K");
    636                          pThis->cmdlen = pThis->cursor;
    637                      break;
    638                      //-----------------------------------------------------
    639                      case KEY_ENQ: // ^E
    640                          terminal_move_cursor (pThis, pThis->cmdlen-pThis->cursor);
    641                          pThis->cursor = pThis->cmdlen;
    642                      break;
    643                      //-----------------------------------------------------
    644                      case KEY_SOH: // ^A
    645                          terminal_reset_cursor (pThis);
    646                          pThis->cursor = 0;
    647                      break;
    648                      //-----------------------------------------------------
    649                      case KEY_ACK: // ^F
    650                      if (pThis->cursor < pThis->cmdlen) {
    651                          terminal_move_cursor (pThis, 1);
    652                          pThis->cursor++;
    653                      }
    654                      break;
    655                      //-----------------------------------------------------
    656                      case KEY_STX: // ^B
    657                      if (pThis->cursor) {
    658                          terminal_move_cursor (pThis, -1);
    659                          pThis->cursor--;
    660                      }
    661                      break;
    662                      //-----------------------------------------------------
    663                      case KEY_DLE: //^P
    664          #ifdef _USE_HISTORY
    665                      hist_search (pThis, _HIST_UP);
    666          #endif
    667                      break;
    668                      //-----------------------------------------------------
    669                      case KEY_SO: //^N
    670          #ifdef _USE_HISTORY
    671                      hist_search (pThis, _HIST_DOWN);
    672          #endif
    673                      break;
    674                      //-----------------------------------------------------
    675                      case KEY_DEL: // Backspace
    676                      case KEY_BS: // ^U
    677                          microrl_backspace (pThis);
    678                          terminal_print_line (pThis, pThis->cursor, pThis->cursor);
    679                      break;
    680          #ifdef _USE_CTLR_C
    681                      case KEY_ETX:
    682                      if (pThis->sigint != NULL)
    683                          pThis->sigint();
    684                      break;
    685          #endif
    686                      //-----------------------------------------------------
    687                      default:
    688                      if ((ch == ' ') && (pThis->cmdlen == 0))
    689                          break;
    690                      if (microrl_insert_text (pThis, (int8_t*)&ch, 1))
    691                          terminal_print_line (pThis, pThis->cursor-1, pThis->cursor);
    692          
    693                      break;
    694                  }
    695          #ifdef _USE_ESC_SEQ
    696              }
    697          #endif
    698          }

   Maximum stack usage in bytes:

     Function                      .cstack
     --------                      -------
     common_len                        16
     escape_process                    16
     fake_serprintf                    12
     get_microrl_printf                 0
     hist_erase_older                   4
     hist_is_space_for_new              4
     hist_restore_line                 24
     hist_save_line                    24
     hist_search                       16
     memcpy                             8
     memmove                            8
     memset                             8
     microrl_backspace                 16
     microrl_get_complite              32
     microrl_init                      16
     microrl_init_printf                4
     microrl_insert_char               16
     microrl_insert_text               24
     microrl_set_complete_callback      0
     microrl_set_execute_callback       0
     microrl_set_sigint_callback        0
     new_line_handler                  24
     print_prompt                       8
     split                             16
     terminal_backspace                 8
     terminal_move_cursor              32
     terminal_newline                   8
     terminal_print_line               24
     terminal_reset_cursor             32
     u16bit_to_str                     28


   Section sizes:

     Function/Label                       Bytes
     --------------                       -----
     memcpy                                 16
     memmove                                16
     memset                                 24
     rl                                    452
     pointerMicrorl                          4
     prompt_default                          4
     fake_serprintf                          8
     hist_erase_older                       26
     hist_is_space_for_new                  50
     hist_save_line                        144
     hist_restore_line                     250
     split                                  84
     print_prompt                           24
     terminal_backspace                     20
     terminal_newline                       20
     u16bit_to_str                          92
     terminal_move_cursor                   92
     terminal_reset_cursor                  78
     terminal_print_line                    92
     microrl_init                           80
     microrl_init_printf                    14
     get_microrl_printf                      8
     microrl_set_complete_callback           8
     microrl_set_execute_callback            8
     microrl_set_sigint_callback             8
     hist_search                            54
     escape_process                        212
     seq                                     4
     microrl_insert_text                   134
     microrl_backspace                      80
     common_len                             52
     microrl_get_complite                  250
     new_line_handler                      140
     microrl_insert_char                   416
     escape                                  4
     ?<Constant "\033[32mIRin >\033[0m ">   20
     ?<Constant "\033[D \033[D">             8
     ??DataTable20                           4
     ??DataTable20_1                         4
     ??DataTable20_2                         4
     ??DataTable20_3                         4
     ??DataTable20_4                         4
     ??DataTable20_5                         4
     ??DataTable20_6                         4
     ??DataTable20_7                         4
     ??DataTable21                           4
     ??DataTable23                           4
     ??DataTable23_1                         4
     ??DataTable23_2                         4
     ??DataTable23_3                         4
     ??DataTable23_4                         4
     ?<Constant "ERROR:too many tokens">    24
     ?<Constant "\r">                        2
     ?<Constant {0}>                         8
     ?<Constant {0}>_1                      16
     ?<Constant "\033[">                     4
     ?<Constant "C">                         2
     ?<Constant "D">                         2
     ?<Constant "D\033[">                    4
     ?<Constant "\033[K">                    4
     ?<Constant {0, 0}>                      2
     ?<Constant "">                          1
     ?<Constant " ">                         2
      Others                                 6

 
   460 bytes in section .bss
     8 bytes in section .data
    67 bytes in section .rodata
 2 594 bytes in section .text
 
 2 532 bytes of CODE  memory (+ 62 bytes shared)
    67 bytes of CONST memory
   468 bytes of DATA  memory

Errors: none
Warnings: none
