###############################################################################
#                                                                             #
#                                                       08/Oct/2012  01:42:14 #
# IAR ANSI C/C++ Compiler V6.21.2.22939/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Projects\google_host\drift-sensor\I2C\i2c1.c          #
#    Command line =  D:\Projects\google_host\drift-sensor\I2C\i2c1.c -D       #
#                    NDEBUG -lc D:\Projects\google_host\drift-sensor\Release\ #
#                    List\ --diag_suppress Pe550 -o                           #
#                    D:\Projects\google_host\drift-sensor\Release\Obj\        #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --endian=little --cpu=ARM7TDMI-S -e --fpu=None           #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    D:\Projects\google_host\drift-sensor\ -I                 #
#                    D:\Projects\google_host\drift-sensor\Config\             #
#                    --interwork --cpu_mode thumb -Om                         #
#    List file    =  D:\Projects\google_host\drift-sensor\Release\List\i2c1.l #
#                    st                                                       #
#    Object file  =  D:\Projects\google_host\drift-sensor\Release\Obj\i2c1.o  #
#                                                                             #
#                                                                             #
###############################################################################

D:\Projects\google_host\drift-sensor\I2C\i2c1.c
      1          /******************************************************************************/
      2          /* i2c1.c                                                                     */
      3          /******************************************************************************/
      4          
      5          
      6          #include "data_types.h"
      7          #include "Core\core.h"
      8          #include "Uart\v_printf.h"
      9          #include "I2c\i2c1.h"
     10          #include "Protothread\pt.h"
     11          
     12          static i2c_data * pData;
     13          
     14          
     15          /*
     16           * Init i2c1
     17           *
     18           */
     19          void init_i2c1() {
     20              PCONP_bit.PCI2C1 = 1;
     21          
     22              I2C1CONCLR = I2C_EN;       // dis module
     23          
     24              // Init pins
     25              PINSEL1_bit.P0_19 = 3;     // SDA0
     26              PINSEL1_bit.P0_20 = 3;     // SCL0
     27          
     28              PINMODE1_bit.P0_19 = 2;    // PULL_RES
     29              PINMODE1_bit.P0_20 = 2;    //
     30          
     31              // Init module I2C1
     32              I2C1SCLH_bit.SCLH = 80;   // Freq 28,8 Mhz / (40 + 40)
     33              I2C1SCLL_bit.SCLL = 80;
     34          
     35              I2C1CONCLR = I2C_AA;       // master mode
     36              I2C1CONCLR = I2C_SI;
     37              I2C1CONCLR = I2C_STA;
     38          
     39              I2C1CONSET = I2C_EN;
     40          }
     41          
     42          
     43          /*
     44           * Start transaction i2c1
     45           *
     46           */
     47          int start_i2c1(void * _pt, i2c_data * _pData) {
     48              // Thread
     49              PT_BEGIN((struct pt *)_pt);
     50          
     51              // Prepare
     52              pData = _pData;
     53              _pData->ind = 0UL;
     54              _pData->isEnd = FALSE_T;
     55              _pData->isOk = FALSE_T;
     56          
     57              I2C1CONSET = I2C_STA;
     58          
     59              PT_WAIT_UNTIL((struct pt *)_pt, _pData->isEnd);
     60          
     61              PT_END((struct pt *)_pt);
     62          }
     63          
     64          
     65          /*
     66           * Int handler
     67           *
     68           */
     69          __irq __arm void __interrupt_handler_i2c1() {
     70              __eSTATUS_I2C status = (__eSTATUS_I2C)I2C1STAT;
     71          
     72              switch (status)
     73              {
     74                  //----------------------------------------------------------------------
     75                  case eI2C_08:   // Start tx
     76                    //DEBUG_PRINTF("\r\n\r\n08_1");
     77                    I2C1DAT = pData->addr;
     78                    I2C1CONCLR = I2C_STA;
     79          
     80                    if (pData->ind >= pData->len) {
     81                        I2C1CONSET = I2C_STO;
     82                        pData->isEnd = TRUE_T;
     83                    };
     84                  break;
     85          
     86                  //----------------------------------------------------------------------
     87                  case eI2C_10:   // Repeat start tx
     88                    //DEBUG_PRINTF("\r\n10_1");
     89                    pData->ind = 0;
     90                    I2C1DAT = pData->addr;
     91                    I2C1CONCLR = I2C_STA;
     92                  break;
     93          
     94                  //----------------------------------------------------------------------
     95                  case eI2C_18:   // ADR+W tx
     96                    //DEBUG_PRINTF("\r\n18_1");
     97                    I2C1DAT = pData->buff[pData->ind++];
     98                  break;
     99          
    100                  //----------------------------------------------------------------------
    101                  case eI2C_20:   // ADR+W tx, but not rx ACK
    102                    //DEBUG_PRINTF("\r\n20_1");
    103                    I2C1CONSET = I2C_STO;
    104                    pData->isEnd = TRUE_T;
    105                   break;
    106          
    107                  //----------------------------------------------------------------------
    108                  case eI2C_28:   // DATA TX
    109                    //DEBUG_PRINTF("\r\n28_1");
    110                    if (pData->ind == pData->len) {
    111                        I2C1CONSET = I2C_STO;
    112                        pData->isEnd = TRUE_T;
    113                        pData->isOk = TRUE_T;
    114                    }
    115                    else {
    116                        I2C1DAT = pData->buff[pData->ind++];
    117                    };
    118                  break;
    119          
    120                  //----------------------------------------------------------------------
    121                  case eI2C_30:   // DATA TX, but not rx ACK
    122                    //DEBUG_PRINTF("\r\n30_1");
    123                    I2C1CONSET = I2C_STO;
    124                    pData->isEnd = TRUE_T;
    125                  break;
    126          
    127                  //----------------------------------------------------------------------
    128                  case eI2C_38:   // Bus busy
    129                    //DEBUG_PRINTF("\r\n38_1");
    130                    I2C1CONSET = I2C_STA;
    131                  break;
    132          
    133                  //----------------------------------------------------------------------
    134                  case eI2C_40:   // ADR+R tx
    135                    //DEBUG_PRINTF("\r\n40_1");
    136                    I2C1CONSET = I2C_AA;
    137                  break;
    138          
    139                  //----------------------------------------------------------------------
    140                  case eI2C_48:   // ADR+R tx, but not rx ACK
    141                    //DEBUG_PRINTF("\r\n48_1");
    142                    I2C1CONSET = I2C_STO;
    143                    pData->isEnd = TRUE_T;
    144                  break;
    145          
    146                  //----------------------------------------------------------------------
    147                  case eI2C_50:   // DATA RX, ACK rx
    148                    //DEBUG_PRINTF("\r\n50_1");
    149                    pData->buff[pData->ind++] = I2C1DAT;
    150                    if (pData->ind == pData->len) {
    151                        I2C1CONCLR = I2C_AA;
    152                    }
    153                    else {
    154                        I2C1CONSET = I2C_AA;
    155                    };
    156                  break;
    157          
    158                  //----------------------------------------------------------------------
    159                  case eI2C_58:   // DATA RX, NO ACK rx
    160                    //DEBUG_PRINTF("\r\n58_1");
    161                    I2C1CONSET = I2C_STO;
    162                    pData->isEnd = TRUE_T;
    163                    pData->isOk = TRUE_T;
    164                  break;
    165          
    166                  //----------------------------------------------------------------------
    167                  default:
    168                    I2C1CONSET = I2C_STO;
    169                    pData->isEnd = TRUE_T;
    170                  break;
    171              };
    172          
    173              I2C1CONCLR = I2C_SI;
    174              VICADDRESS = 0;
    175          }
    176          
    177          

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     __interrupt_handler_i2c1     16
     init_i2c1                     4
     start_i2c1                    4


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     _A_PCONP                    4
     VICADDRESS                  4
     _A_PINSEL1                  4
     _A_PINMODE1                 4
     _A_I2C1CONSET               4
     _A_I2C1STAT                 4
     _A_I2C1DAT                  4
     _A_I2C1SCLH                 4
     _A_I2C1SCLL                 4
     _A_I2C1CONCLR               4
     pData                       4
     init_i2c1                 102
     start_i2c1                 52
     __interrupt_handler_i2c1  412
     ??DataTable2                4
     ??DataTable2_1              4
     ??DataTable2_2              4
     ??DataTable2_3              4
     ??DataTable2_4              4
     ??DataTable2_5              4

 
   4 bytes in section .bss
  40 bytes in section .data
 590 bytes in section .text
 
 590 bytes of CODE memory
   4 bytes of DATA memory (+ 40 bytes shared)

Errors: none
Warnings: none
