###############################################################################
#                                                                             #
#                                                       08/Oct/2012  01:42:20 #
# IAR ANSI C/C++ Compiler V6.21.2.22939/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Projects\google_host\drift-sensor\Tasks\tasks.c       #
#    Command line =  D:\Projects\google_host\drift-sensor\Tasks\tasks.c -D    #
#                    NDEBUG -lc D:\Projects\google_host\drift-sensor\Release\ #
#                    List\ --diag_suppress Pe550 -o                           #
#                    D:\Projects\google_host\drift-sensor\Release\Obj\        #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --endian=little --cpu=ARM7TDMI-S -e --fpu=None           #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    D:\Projects\google_host\drift-sensor\ -I                 #
#                    D:\Projects\google_host\drift-sensor\Config\             #
#                    --interwork --cpu_mode thumb -Om                         #
#    List file    =  D:\Projects\google_host\drift-sensor\Release\List\tasks. #
#                    lst                                                      #
#    Object file  =  D:\Projects\google_host\drift-sensor\Release\Obj\tasks.o #
#                                                                             #
#                                                                             #
###############################################################################

D:\Projects\google_host\drift-sensor\Tasks\tasks.c
      1          /******************************************************************************/
      2          /* tasks.c                                                                    */
      3          /******************************************************************************/
      4          
      5          
      6          #include "data_types.h"
      7          #include "Core\core.h"
      8          #include "Uart\v_printf.h"
      9          #include "Protothread\pt.h"
     10          #include "Led\led.h"
     11          #include "Lis3dh\lis3dh.h"
     12          #include "Compass\compass.h"
     13          #include "Drift\drift.h"
     14          #include "Tasks\tasks.h"
     15          
     16          static uint32_t flag_run_enabled = 0;
     17          static uint32_t enabled_tasks = 0;
     18          static uint16_t calibrating_state = 0;
     19          
     20          #define ACC_TASK          1
     21          #define ACC_MATRIX_TASK   2
     22          #define CALIBR_TASK       6
     23          
     24          static struct pt first_pt;
     25          static struct pt acc_pt;
     26          static struct pt acc_matrix_pt;
     27          static struct pt calibr_pt;
     28          static struct pt led_pt;
     29          
     30          
     31          /*
     32           * First task
     33           *
     34           */
     35          static int first_task(struct pt * pt) {
     36              static uint32_t ticks = 0;
     37              PT_BEGIN(pt);
     38          
     39              while(1) {
     40                  PT_WAIT_UNTIL(pt, !(get_sys_tick() % 4) && ticks != get_sys_tick());
     41                  ticks = get_sys_tick();
     42                  flag_run_enabled = 1;
     43              }
     44          
     45              PT_END(pt);
     46          }
     47          
     48          
     49          /*
     50           * Calibrating task
     51           *
     52           */
     53          static int calibr_task(struct pt * pt) {
     54              static uint32_t time_count = 0;
     55              PT_BEGIN(pt);
     56          
     57              while(1) {
     58                  PT_WAIT_UNTIL(pt, flag_run_enabled);
     59                  {
     60                      read_acc_lis3dh();
     61                      vector * pA = get_acc_lis3dh();
     62          
     63                      switch (calibrating_state) {
     64                          //--------------------------------------------------------------
     65                          case 0:      // initial state
     66                              init_calibrating_data();
     67                              time_count = get_sys_tick() + 3 * TIMER0_TICK;
     68                              DEBUG_PRINTF("Starting calibration.\r\nStage 1 - accumulation quiet-data\r\nWait 3 sec...\r\n");
     69                              serprintf("$DRIFT,STAGE1\r\n");
     70                              calibrating_state++;
     71                              
     72                              disable_acc_matrix_task();
     73                              break;
     74          
     75                          //--------------------------------------------------------------
     76                          case 1:      // accumulation quiet
     77                              {
     78                                  add_acc_samples_in_calibr(pA->x, pA->y, pA->z);
     79                                  uint32_t tick = get_sys_tick();
     80                                  if (tick > time_count) {
     81                                      DEBUG_PRINTF("\r\nStage 2 - Lets go! You have 20 sec.\r\n");
     82                                      calibrating_state++;
     83                                      
     84                                      commit_quiet_calibr_data();
     85                                      time_count = tick + 20 * TIMER0_TICK;
     86                                  } else if (!(tick % (TIMER0_TICK / 2))) {
     87                                      DEBUG_PRINTF(".");
     88                                  }
     89                              }
     90                              break;
     91          
     92                          //--------------------------------------------------------------
     93                          case 2:     // braking
     94                              {
     95                                  add_acc_samples_in_calibr(pA->x, pA->y, pA->z);
     96                                  handle_acc_samples_in_calibr();
     97                                  uint32_t tick = get_sys_tick();
     98                                  if (tick > time_count) {
     99                                      DEBUG_PRINTF("\r\nStage 2 - finished.\r\n\r\n");
    100                                      serprintf("$DRIFT,STAGE2\r\n");
    101                                      calibrating_state++;
    102                                      
    103                                      sint16_t result = commit_motion_calibr_data();
    104                                      DEBUG_PRINTF("Result err = %d.\r\n\r\n", result);
    105                                      
    106                                      print_calibr_results();
    107                                      disable_calibr_task();
    108                                      enable_acc_matrix_task();
    109                                  } else if (!(tick % TIMER0_TICK)) {
    110                                      DEBUG_PRINTF(".");
    111                                  }
    112                              }
    113                              break;
    114          
    115                          //--------------------------------------------------------------
    116                          default:
    117                              break;
    118                      }
    119                  }
    120                  PT_WAIT_UNTIL(pt, !flag_run_enabled);
    121              }
    122          
    123              PT_END(pt);
    124          }
    125          
    126          
    127          /*
    128           * Accelerometer task
    129           *
    130           */
    131          static int acc_task(struct pt * pt) {
    132          
    133              PT_BEGIN(pt);
    134          
    135              while(1) {
    136                  PT_WAIT_UNTIL(pt, flag_run_enabled);
    137                  {
    138                      read_acc_lis3dh();
    139                      vector * pA = get_acc_lis3dh();
    140          
    141                      DEBUG_PRINTF("acc=%d,%d,%d,%d\r\n", pA->x, pA->y, pA->z, pA->status);
    142          
    143                      if (!get_trace())
    144                          add_acc_samples_in_reco_drift(pA->x, pA->y, pA->z);
    145                  }
    146                  PT_WAIT_UNTIL(pt, !flag_run_enabled);
    147              }
    148          
    149              PT_END(pt);
    150          }
    151          
    152          
    153          /*
    154           * Accelerometer matrix task
    155           *
    156           */
    157          static int acc_matrix_task(struct pt * pt) {
    158          
    159              PT_BEGIN(pt);
    160          
    161              while(1) {
    162                  PT_WAIT_UNTIL(pt, flag_run_enabled);
    163                  {
    164                      read_acc_lis3dh();
    165                      vector * pA = get_acc_lis3dh();
    166                      add_acc_matrix_samples_in_reco_drift(pA->x, pA->y, pA->z);
    167                  }
    168                  PT_WAIT_UNTIL(pt, !flag_run_enabled);
    169              }
    170          
    171              PT_END(pt);
    172          }
    173          
    174          
    175          /*
    176           * Led task
    177           *
    178           */
    179          static int led_task(struct pt * pt) {
    180              static uint32_t time_count = 0;
    181              PT_BEGIN(pt);
    182          
    183              while(1) {
    184                  PT_WAIT_UNTIL(pt, flag_run_enabled);
    185                  {
    186          
    187                      switch (get_led1_state()) {
    188                          //--------------------------------------------------------------
    189                          case 0:      // off state
    190                              {
    191                                  uint32_t tick = get_sys_tick();
    192                                  if (tick > time_count) {
    193                                      time_count = tick + TIMER0_TICK / 50;
    194                                      led1_on();
    195                                  }
    196                              }
    197                              break;
    198          
    199                          //--------------------------------------------------------------
    200                          case 1:      // on state
    201                              {
    202                                  uint32_t tick = get_sys_tick();
    203                                  if (tick > time_count) {
    204                                      time_count = tick + TIMER0_TICK / 2;
    205                                      led1_off();
    206                                  }
    207                              }
    208                              break;
    209          
    210                          //--------------------------------------------------------------
    211                          default:
    212                              led1_off();
    213                              break;
    214                      }
    215                  }
    216                  PT_WAIT_UNTIL(pt, !flag_run_enabled);
    217              }
    218          
    219              PT_END(pt);
    220          }
    221          
    222          
    223          /*
    224           * Test acc task
    225           *
    226           */
    227          static bool_t test_acc_task() {
    228              return BIT_TEST(enabled_tasks, ACC_TASK) ? TRUE_T : FALSE_T;
    229          }
    230          
    231          
    232          /*
    233           * Enable acc task
    234           *
    235           */
    236          void enable_acc_task() {
    237              BIT_SET(enabled_tasks, ACC_TASK);
    238          }
    239          
    240          
    241          /*
    242           * Disable acc task
    243           *
    244           */
    245          void disable_acc_task() {
    246              BIT_CLEAR(enabled_tasks, ACC_TASK);
    247          }
    248          
    249          
    250          /*
    251           * Test acc matrix task
    252           *
    253           */
    254          static bool_t test_acc_matrix_task() {
    255              return BIT_TEST(enabled_tasks, ACC_MATRIX_TASK) ? TRUE_T : FALSE_T;
    256          }
    257          
    258          
    259          /*
    260           * Enable acc matrix task
    261           *
    262           */
    263          void enable_acc_matrix_task() {
    264              BIT_SET(enabled_tasks, ACC_MATRIX_TASK);
    265          }
    266          
    267          
    268          /*
    269           * Disable acc matrix task
    270           *
    271           */
    272          void disable_acc_matrix_task() {
    273              BIT_CLEAR(enabled_tasks, ACC_MATRIX_TASK);
    274          }
    275          
    276          
    277          /*
    278           * Test calibr task
    279           *
    280           */
    281          static bool_t test_calibr_task() {
    282              return BIT_TEST(enabled_tasks, CALIBR_TASK) ? TRUE_T : FALSE_T;
    283          }
    284          
    285          
    286          /*
    287           * Enable calibr task
    288           *
    289           */
    290          void enable_calibr_task() {
    291              BIT_SET(enabled_tasks, CALIBR_TASK);
    292              calibrating_state = 0;
    293          }
    294          
    295          
    296          /*
    297           * Disable calibr task
    298           *
    299           */
    300          void disable_calibr_task() {
    301              BIT_CLEAR(enabled_tasks, CALIBR_TASK);
    302          }
    303          
    304          
    305          /*
    306           * Init tasks
    307           *
    308           */
    309          void init_tasks() {
    310              PT_INIT(&first_pt);
    311              PT_INIT(&led_pt);
    312              PT_INIT(&calibr_pt);
    313              PT_INIT(&acc_pt);
    314              PT_INIT(&acc_matrix_pt);
    315              
    316              //enable_acc_matrix_task();
    317              enable_acc_task();
    318          }
    319          
    320          
    321          /*
    322           * Run tasks
    323           *
    324           */
    325          void run_tasks() {
    326              first_task(&first_pt);
    327              
    328              led_task(&led_pt);
    329          
    330              if (test_calibr_task()) {
    331                  calibr_task(&calibr_pt);
    332                  flag_run_enabled = 0;
    333                  return;
    334              }
    335          
    336              if (test_acc_matrix_task()) {
    337                  acc_matrix_task(&acc_matrix_pt);
    338              }
    339          
    340              if (test_acc_task()) {
    341                  acc_task(&acc_pt);
    342              }
    343          
    344              flag_run_enabled = 0;
    345          }
    346          
    347          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     acc_matrix_task              8
     acc_task                    24
     calibr_task                 16
     disable_acc_matrix_task      0
     disable_acc_task             0
     disable_calibr_task          0
     enable_acc_matrix_task       0
     enable_acc_task              0
     enable_calibr_task           0
     first_task                  16
     init_tasks                   8
     led_task                    16
     run_tasks                    8
     test_acc_matrix_task         0
     test_acc_task                0
     test_calibr_task             0


   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     first_task                                 68
     calibr_task                               378
     acc_task                                  130
     acc_matrix_task                            80
     led_task                                  120
     calibrating_state                          44
     first_pt
     acc_pt
     acc_matrix_pt
     calibr_pt
     led_pt
     flag_run_enabled
     enabled_tasks
     ticks
     time_count
     time_count
     test_acc_task                              12
     enable_acc_task                            12
     disable_acc_task                           12
     test_acc_matrix_task                       12
     enable_acc_matrix_task                     12
     disable_acc_matrix_task                    12
     test_calibr_task                           12
     enable_calibr_task                         16
     disable_calibr_task                        12
     init_tasks                                 24
     run_tasks                                  84
     ?<Constant ".">                             2
     ?<Constant "Starting calibration....">     76
     ?<Constant "$DRIFT,STAGE1\r\n">            16
     ?<Constant "\r\nStage 2 - Lets go! ...">   40
     ?<Constant "\r\nStage 2 - finished....">   28
     ?<Constant "$DRIFT,STAGE2\r\n">            16
     ?<Constant "Result err = %d.\r\n\r\n">     24
     ??DataTable10                               4
     ??DataTable19                               4
     ??DataTable23                               4
     ?<Constant "acc=%d,%d,%d,%d\r\n">          20
      Others                                     6

 
    44 bytes in section .bss
     2 bytes in section .rodata
 1 234 bytes in section .text
 
 1 228 bytes of CODE  memory (+ 6 bytes shared)
     2 bytes of CONST memory
    44 bytes of DATA  memory

Errors: none
Warnings: none
