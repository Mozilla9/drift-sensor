###############################################################################
#                                                                             #
#                                                       08/Oct/2012  01:42:17 #
# IAR ANSI C/C++ Compiler V6.21.2.22939/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Projects\google_host\drift-sensor\Matrix\matrix.c     #
#    Command line =  D:\Projects\google_host\drift-sensor\Matrix\matrix.c -D  #
#                    NDEBUG -lc D:\Projects\google_host\drift-sensor\Release\ #
#                    List\ --diag_suppress Pe550 -o                           #
#                    D:\Projects\google_host\drift-sensor\Release\Obj\        #
#                    --no_unroll --no_inline --no_tbaa --no_scheduling        #
#                    --endian=little --cpu=ARM7TDMI-S -e --fpu=None           #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    D:\Projects\google_host\drift-sensor\ -I                 #
#                    D:\Projects\google_host\drift-sensor\Config\             #
#                    --interwork --cpu_mode thumb -Om                         #
#    List file    =  D:\Projects\google_host\drift-sensor\Release\List\matrix #
#                    .lst                                                     #
#    Object file  =  D:\Projects\google_host\drift-sensor\Release\Obj\matrix. #
#                    o                                                        #
#                                                                             #
#                                                                             #
###############################################################################

D:\Projects\google_host\drift-sensor\Matrix\matrix.c
      1          /******************************************************************************/
      2          /* matrix.c                                                                   */
      3          /******************************************************************************/
      4          
      5          #include "data_types.h"
      6          #include <math.h>
      7          #include "matrix\matrix.h"
      8          
      9          
     10          
     11          #define DIM_SIZE    3
     12          #define EE          0.00001f
     13          
     14          
     15          
     16          /*
     17           * rotate Z
     18           *
     19           * input: asc_data[]
     20           * output: rotation_z[]
     21           *
     22           */
     23          static sint16_t rotate_z(const sint16_t acs_data[], float32_t rotation_z[]) {
     24              float32_t axis_len = 0;
     25              float32_t data_len = 0;
     26              float32_t turn_cos = 0;
     27              float32_t turn_sin = 0;
     28              float32_t axis[DIM_SIZE] = {0, 0, 0};
     29              
     30              /* axis vector length */
     31              axis_len = sqrt((float32_t)(acs_data[0] * acs_data[0] + acs_data[1] * acs_data[1]));
     32          
     33              if(axis_len < EE)
     34                  return -1;
     35          
     36              /* axis vector coordinates */
     37              axis[0] = acs_data[1] / axis_len;
     38              axis[1] = - acs_data[0] / axis_len;
     39          
     40              /* turn angle cos and sin */
     41              data_len = sqrt((float32_t)(acs_data[0] * acs_data[0] + acs_data[1] * acs_data[1] + acs_data[2] * acs_data[2]));
     42          
     43              if(data_len < EE)
     44                  return -2;
     45          
     46              turn_cos = acs_data[2] / data_len;
     47              turn_sin = sqrt(1 - turn_cos * turn_cos);
     48          
     49              /* rotation matrix components */
     50              rotation_z[0] = turn_cos + (1 - turn_cos) * axis[0] * axis[0];
     51              rotation_z[1] = (1 - turn_cos) * axis[0] * axis[1];
     52              rotation_z[2] = turn_sin * axis[1];
     53          
     54              rotation_z[3] = (1 - turn_cos) * axis[0] * axis[1];
     55              rotation_z[4] = turn_cos + (1 - turn_cos) * axis[1] * axis[1];
     56              rotation_z[5] = - turn_sin * axis[0];
     57          
     58              rotation_z[6] = - turn_sin * axis[1];
     59              rotation_z[7] = turn_sin * axis[0];
     60              rotation_z[8] = turn_cos;
     61          
     62              return 0;
     63          }
     64          
     65          
     66          /*
     67           * rotate X
     68           *
     69           * input:  asc_data[]
     70           * input:  rotation_z[]
     71           * output: rotation_x[]
     72           */
     73          static sint16_t rotate_x(const sint16_t acs_data[], const float32_t rotation_z[], float32_t rotation_x[]) {
     74              float32_t turn_data[DIM_SIZE];
     75              float32_t data_len = 0;
     76          
     77              /* rotation input vector */
     78              multiply(acs_data, rotation_z, turn_data);
     79          
     80              data_len = sqrt(turn_data[0] * turn_data[0] + turn_data[1] * turn_data[1]);
     81          
     82              if(data_len < EE)
     83                  return -1;
     84          
     85              /* rotation matrix components */
     86              rotation_x[0] = turn_data[0] / data_len;
     87              rotation_x[1] = turn_data[1] / data_len;
     88              rotation_x[2] = 0;
     89          
     90              rotation_x[3] = - turn_data[1] / data_len;
     91              rotation_x[4] = turn_data[0] / data_len;
     92              rotation_x[5] = 0;
     93          
     94              rotation_x[6] = 0;
     95              rotation_x[7] = 0;
     96              rotation_x[8] = 1;
     97          
     98              return 0;
     99          }
    100          
    101          
    102          /*
    103           * matrix multiply
    104           * input: matrix1[], matrix2[]
    105           * output: output_matrix[]
    106           *
    107           */
    108          static void matrix_multiply(const float32_t matrix1[], const float32_t matrix2[], float32_t output_matrix[]) {
    109              output_matrix[0] = matrix1[0] * matrix2[0] + matrix1[1] * matrix2[3] + matrix1[2] * matrix2[6];
    110              output_matrix[1] = matrix1[0] * matrix2[1] + matrix1[1] * matrix2[4] + matrix1[2] * matrix2[7];
    111              output_matrix[2] = matrix1[0] * matrix2[2] + matrix1[1] * matrix2[5] + matrix1[2] * matrix2[8];
    112          
    113              output_matrix[3] = matrix1[3] * matrix2[0] + matrix1[4] * matrix2[3] + matrix1[5] * matrix2[6];
    114              output_matrix[4] = matrix1[3] * matrix2[1] + matrix1[4] * matrix2[4] + matrix1[5] * matrix2[7];
    115              output_matrix[5] = matrix1[3] * matrix2[2] + matrix1[4] * matrix2[5] + matrix1[5] * matrix2[8];
    116          
    117              output_matrix[6] = matrix1[6] * matrix2[0] + matrix1[7] * matrix2[3] + matrix1[8] * matrix2[6];
    118              output_matrix[7] = matrix1[6] * matrix2[1] + matrix1[7] * matrix2[4] + matrix1[8] * matrix2[7];
    119              output_matrix[8] = matrix1[6] * matrix2[2] + matrix1[7] * matrix2[5] + matrix1[8] * matrix2[8];
    120          }
    121          
    122          
    123          /*
    124           * multiply
    125           * input: input_vector[], matrix[]
    126           * output: output_vector[]
    127           *
    128           */
    129          void multiply(const sint16_t input_vector[], const float32_t matrix[], float32_t output_vector[]) {
    130              output_vector[0] = input_vector[0] * matrix[0] + input_vector[1] * matrix[1] + input_vector[2] * matrix[2];
    131              output_vector[1] = input_vector[0] * matrix[3] + input_vector[1] * matrix[4] + input_vector[2] * matrix[5];
    132              output_vector[2] = input_vector[0] * matrix[6] + input_vector[1] * matrix[7] + input_vector[2] * matrix[8];
    133          }
    134          
    135          
    136          /*
    137           * rotate
    138           * input: asc_data1[], acs_data2[]
    139           * output: rotation[]
    140           *
    141           */
    142          sint16_t rotate(const sint16_t acs_data1[], const sint16_t acs_data2[], float32_t rotation[]) {
    143              float32_t rotation_z[9];
    144              float32_t rotation_x[9];
    145              sint16_t rezult;
    146              rezult = rotate_z(acs_data1, rotation_z);
    147              
    148              if(rezult)
    149                  return rezult;
    150              
    151              rezult = rotate_x(acs_data2, rotation_z, rotation_x);
    152              
    153              if(rezult)
    154                  return rezult;
    155              
    156              matrix_multiply(rotation_x, rotation_z, rotation);
    157              return 0;
    158          }

   Maximum stack usage in bytes:

     Function        .cstack
     --------        -------
     matrix_multiply     20
     multiply            20
     rotate              88
     rotate_x            32
     rotate_z            48


   Section sizes:

     Function/Label                       Bytes
     --------------                       -----
     rotate_z                              340
     rotate_x                              140
     matrix_multiply                       428
     multiply                              216
     rotate                                 52
     ??DataTable2                            4
     ?<Constant {(0.0F), (0.0F), (0.0F)}>   12

 
    12 bytes in section .rodata
 1 180 bytes in section .text
 
 1 180 bytes of CODE  memory
    12 bytes of CONST memory

Errors: none
Warnings: none
